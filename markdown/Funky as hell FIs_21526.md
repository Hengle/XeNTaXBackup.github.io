## Post #1
- Username: Machinedramon
- Rank: advanced
- Number of posts: 77
- Joined date: Tue Apr 09, 2019 1:13 am
- Post datetime: 2019-12-23T12:21:16+00:00
- Post Title: Funky as hell FIs

So, been lately trying to understand the FI format of the models from TXR Drift 2.....

but at the same time the model files dont seem to make much sense, all i know is that there are vertex formats and then there are uvs, then there is a int, maybe shorts? that dont make much sense to me.... if anyone can enlighten me....

this would be the breakdown of my research


and here a preview creating a list of FF strip list by using every mesh as entry-out, though it isnt fully working....



[https://gofile.io/?c=hg5XLj](https://gofile.io/?c=hg5XLj)

here the file....
## Post #2
- Username: Bigchillghost
- Rank: double-veteran
- Number of posts: 1031
- Joined date: Tue Jul 05, 2016 4:37 pm
- Post datetime: 2019-12-23T15:19:31+00:00
- Post Title: Funky as hell FIs

First submesh:



square.jpg (102.63 KiB) Viewed 287 times
## Post #3
- Username: shakotay2
- Rank: MEGAVETERAN
- Number of posts: 4300
- Joined date: Fri Apr 20, 2012 4:24 pm
- Post datetime: 2019-12-23T16:42:30+00:00
- Post Title: Funky as hell FIs

> Reply from Machinedramon ↑Mon Dec 23, 2019 8:21 pm at Mon Dec 23, 2019 8:21 pm
>
> and here a preview creating a list of FF strip list by using every mesh as entry-out, though it isnt fully working...."every mesh as entry-out"? Dunno, what that means exactly.  

You may get the uvs as from bigchillghost proposed.
I just interpreted them as words before I saw he posted already...
.



fAsHell.png (90.02 KiB) Viewed 286 times



well, forget about my uvs, I used a fixed block before them which seems to be variabel...
## Post #4
- Username: Machinedramon
- Rank: advanced
- Number of posts: 77
- Joined date: Tue Apr 09, 2019 1:13 am
- Post datetime: 2019-12-23T17:10:38+00:00
- Post Title: Funky as hell FIs

Nice! thanks for an early repply guys! the only problem for me here is that rn im kinda trying to find a fix for the fis, for instance in my screen or the one that shakotay just posted, more or less its how it shall look, but there are lots of wrong triangulation that binds parts of the meshes that should not be binded, what i meant in-out is that i autogenerated a tristrip and added a FFFF at the in and out to separate meshes, but even still the geometry is not working as it should, from my research, 1c4 are actually the uvs, in shorts(not quite sure if signed or not), then 1d8 is some weird stuff i dont quite understand but doesnt make sense to be the uvs, it repeats itself too much, at first i though it was some sort of code for the FIs, like stating where jumps happen, but on the other hand it kinda changes too much to be as simple....


here more test files...


[https://gofile.io/?c=J4uDeO](https://gofile.io/?c=J4uDeO)

here the three together, like i said, the mesh should be more clean, even with backface culling, its kinda close but not as it should look
## Post #5
- Username: Machinedramon
- Rank: advanced
- Number of posts: 77
- Joined date: Tue Apr 09, 2019 1:13 am
- Post datetime: 2019-12-23T17:13:29+00:00
- Post Title: Funky as hell FIs

```

f = mrp.get_bfile()

verts = []
uvs = []
faces = []
curfi = -1
mat = open('mat.txt', 'w')
variables = []

print ("***************")
meshnum = f.readInt()
jump = (meshnum*16-4)
f.seek(jump,1)
print ("start "+f.tellHex())
for i in range(meshnum):
    verts = []
    uvs = []
    faces = []
    curfi = -1
    curmesha =("mesh"+str(i))
    f.seek(20,1)
    repeat = f.readInt()
    f.seek(40,1)
    for i in range(repeat):
        start = f.tell()
        leng = f.readShort()
        meshleng = ((leng*16)+16)
        if leng != 0:
            f.seek(10,1)
            count = f.readint()
            f.seek(48,1)
            for i in range(count):
                verts.append(f.read3Float())
            f.seek(4,1)
            for i in range(count):
                uv = f.read2Short()
                uvs.append(uv)
            f.seek(4,1)
            print (f.tellHex())
            for i in range(count):
                curfi = curfi + 1
                faces.append(curfi)
                #new = f.readInt()
                #if (len(variables) == 0:
                #    variables.append(new)
                    
            faces.append(65535)
            f.seek(start)
            f.seek(meshleng,1)
        #faces.append(65535)       
    mrp.create_mesh(curmesha)
    mesh = mrp.get_mesh(curmesha)
    mesh.set_vertices(verts)
    mesh.set_faces(faces,fm="TStripFF")
    mesh.set_uvs(uvs,tp="Short")
    mrp.render(curmesha)
    mrp.print_mesh()

print ("end "+f.tellHex())
print ("------------------")

```


here a snippet of my code, rn kinda trying to figure out how the whole FIS format works on these files, almost the whole game uses the same format without explicit FIs, i saw something alike on txr3, but it worked just fine autogenerating them
## Post #6
- Username: Bigchillghost
- Rank: double-veteran
- Number of posts: 1031
- Joined date: Tue Jul 05, 2016 4:37 pm
- Post datetime: 2019-12-24T05:10:22+00:00
- Post Title: Funky as hell FIs

> Reply from Machinedramon ↑Tue Dec 24, 2019 1:10 am at Tue Dec 24, 2019 1:10 am
>
> 
here more test files...
It seems that "something went wrong" of that site. Failed to download the files.

> Reply from Machinedramon ↑Tue Dec 24, 2019 1:10 am at Tue Dec 24, 2019 1:10 am
>
> 
the only problem for me here is that rn im kinda trying to find a fix for the fis, for instance in my screen or the one that shakotay just posted, more or less its how it shall look, but there are lots of wrong triangulation that binds parts of the meshes that should not be binded
...
here the three together, like i said, the mesh should be more clean, even with backface culling, its kinda close but not as it should look
From your screenshot looks like it's not just a problem of the face indices, but also the positions and scalings of the objects.

> Reply from Machinedramon ↑Tue Dec 24, 2019 1:10 am at Tue Dec 24, 2019 1:10 am
>
> then 1d8 is some weird stuff i dont quite understand but doesnt make sense to be the uvs, it repeats itself too much, at first i though it was some sort of code for the FIs, like stating where jumps happen, but on the other hand it kinda changes too much to be as simple....
These are the normal vectors. Except that they're not entirely encoded as ordinary chars or bytes. My guess would be 1 MSB for the sign + 7 bits for the value.

> Reply from Machinedramon ↑Tue Dec 24, 2019 1:13 am at Tue Dec 24, 2019 1:13 am
>
> 
Code: Select allfor i in range(meshnum):
    verts = []
    uvs = []
    faces = []
    curfi = -1
    ...
    ...
            for i in range(count):
                curfi = curfi + 1
                faces.append(curfi)
                #new = f.readInt()
                #if (len(variables) == 0:
                #    variables.append(new)
                    
            faces.append(65535)


here a snippet of my code, rn kinda trying to figure out how the whole FIS format works on these files, almost the whole game uses the same format without explicit FIs, i saw something alike on txr3, but it worked just fine autogenerating them
I guess your "faces" tuple is filled with int32 elements while the magic flag for tristrip is "-1", aka 0xFFFF for uint16 indices, or 0xFFFFFFFF for int32 indices. That's why you got objects bound to each other.
## Post #7
- Username: Machinedramon
- Rank: advanced
- Number of posts: 77
- Joined date: Tue Apr 09, 2019 1:13 am
- Post datetime: 2019-12-24T10:29:07+00:00
- Post Title: Funky as hell FIs

So thinking about it this might be actually an interesting aproach, sorry, i didnt quite read the offsets at the first image you sent, interestingly normals could actually work as helpers for proper backface culling.... I will do some testing, thanks for a new insight! 

Regarding possition and scalling id say its working fine, the meshes do fit from one file to the next exactly as inted making the road.... I mean i could even clean the meshes manually, but its a heavy work and want to find a propper solution, there are still also lots of things i gotta test about materials and texture listings
## Post #8
- Username: Machinedramon
- Rank: advanced
- Number of posts: 77
- Joined date: Tue Apr 09, 2019 1:13 am
- Post datetime: 2019-12-24T11:49:47+00:00
- Post Title: Funky as hell FIs

okay, sorry to bother once again, but how do i turn those bytes into decimal values? just been trying to find more information about how can i code that myself but.... i know about how to do it with halfs, bytes/chars dont even know where to start, how do you do it in your program?
## Post #9
- Username: Bigchillghost
- Rank: double-veteran
- Number of posts: 1031
- Joined date: Tue Jul 05, 2016 4:37 pm
- Post datetime: 2019-12-24T12:53:44+00:00
- Post Title: Funky as hell FIs

> Reply from Machinedramon ↑Tue Dec 24, 2019 7:49 pm at Tue Dec 24, 2019 7:49 pm
>
> 
how do i turn those bytes into decimal values?
Click the "Normals" button of AMR to interpret the values.

> Reply from Machinedramon ↑Tue Dec 24, 2019 7:49 pm at Tue Dec 24, 2019 7:49 pm
>
> 
just been trying to find more information about how can i code that myself but.... i know about how to do it with halfs, bytes/chars dont even know where to start, how do you do it in your program?
Char is easy enough: 

```
decodedValue = charValue / 127.0;
```

For byte, 

```
decodedValue = byteValue * 2.0 / 255.0 - 1.0;
```

But in your case, it should be 

```
if (byteValue > 0x7F)
    decodedValue = -decodedValue;
```

Havn't tested it though.
## Post #10
- Username: Machinedramon
- Rank: advanced
- Number of posts: 77
- Joined date: Tue Apr 09, 2019 1:13 am
- Post datetime: 2019-12-24T13:16:19+00:00
- Post Title: Funky as hell FIs

oh so basically either taking it signed or unsigned and dividing by the max value, interesting, will give it a try


though here an interesting insight....



this is the normals breakdown on advanced research model note that 5 and 6 should have 0 for normals... but then



analyzing the mesh in 3d max, the faulty ones are 22 and 23 out of the 24 faces... those were listed before in the list as the second 47....

while 24 needs to be flipped(tristrip error cause it is interpreted as aa cc bb)





lastly the correction, i think for this reason i used to try and do a comparison algorithm first, though it doesnt work properly cause how much the variables change.... might the values actually be color coding for the faces?
## Post #11
- Username: Machinedramon
- Rank: advanced
- Number of posts: 77
- Joined date: Tue Apr 09, 2019 1:13 am
- Post datetime: 2019-12-24T18:46:01+00:00
- Post Title: Funky as hell FIs

so.... been trying some things....

by using the last byte of those ints getting interesting results.... now i was able to split the trees properly, even the mesh i showed before, used the first FF as a marker, then ignored a second one, as if those bytes would mix together to form 0xFFFF, kinda funny.... but the street detail still has lots of stuff i havent yet fully figured out...




```

f = mrp.get_bfile()

verts = []
uvs = []
faces = []
curfi = -1
mat = open('mat.txt', 'w')
variables = []
new = 0

print ("***************")
meshnum = f.readInt()
jump = (meshnum*16-4)
f.seek(jump,1)
print ("start "+f.tellHex())
for i in range(meshnum):
    print("mesh "+ str(i)+"\n",file = mat)
    curmesh = "mesh_"+str(i)
    f.seek(20,1)
    repeat = f.readInt()
    f.seek(40,1)
    for i in range(repeat):
        print("repeat "+ str(i)+"\n",file = mat)
        currep="_rep_"+str(i)
        curmesha =curmesh+currep
        verts = []
        uvs = []
        faces = []
        curfi = -1
        start = f.tell()
        leng = f.readShort()
        meshleng = ((leng*16)+16)
        if leng != 0:
            f.seek(10,1)
            count = f.readint()
            f.seek(48,1)
            for i in range(count):
                verts.append(f.read3Float())
            f.seek(4,1)
            for i in range(count):
                uv = f.read2short()
                uvs.append(uv)
            f.seek(4,1)
            ffcheck = 0
            print (curmesh+"\t"+currep+"\t"+str(f.tellHex()))
            for i in range(count):
                curfi = curfi + 1
                f.seek(3,1)
                read = f.readByte()
                if read == 255:
                    if ffcheck == 0:
                        print("\n\t\t\t\t\tFFFF",file = mat)
                        faces.append(65535)
                        ffcheck = 1
                    else:
                        ffcheck = 0
                else:
                    ffcheck = 0
                faces.append(curfi)
                #new = read
                #if (len(variables) == 0:
                #    variables.append(new)
                print ("current face "+str(i)+"\t"+hex(read), file = mat)    
            faces.append(65535)
            f.seek(start)
            f.seek(meshleng,1)
        #faces.append(65535)       
        mrp.create_mesh(curmesha)
        mesh = mrp.get_mesh(curmesha)
        mesh.set_vertices(verts)
        mesh.set_faces(faces,fm="TStripFF")
        mesh.set_uvs(uvs,tp="Short")
        mesh.set_uvs_indices(faces,fm="TStripFF")
        mrp.render(curmesha)
        mrp.print_mesh()
    print("\n---------------------------------------------------------------------------\n",file = mat)


print ("end "+f.tellHex())
print ("------------------")

```
## Post #12
- Username: Bigchillghost
- Rank: double-veteran
- Number of posts: 1031
- Joined date: Tue Jul 05, 2016 4:37 pm
- Post datetime: 2019-12-25T01:41:39+00:00
- Post Title: Funky as hell FIs

> Reply from Machinedramon ↑Tue Dec 24, 2019 9:16 pm at Tue Dec 24, 2019 9:16 pm
>
> 
though here an interesting insight....
You got the same source bytes from line 3 to line 23 but totally different interpretation values, how?

Here's a mesh with all negative bytes after the UV data block.



nm.png (55.96 KiB) Viewed 211 times


Interpreting them as char/byte doesn't give a normalized vector(as byte occasionally several values do though), nor with the MSB + value method. The square sum of the first 3 bytes is close to 1.0 only when they're all positive values. But they're off the right directions anyway. The 4th byte do seem to be some kind of flag. Maybe it's the normals packed with the tangents or something. But that's beyond my recognition and interest. 

> Reply from Machinedramon ↑Tue Dec 24, 2019 9:16 pm at Tue Dec 24, 2019 9:16 pm
>
> 
might the values actually be color coding for the faces?
You meant vertex colors?

> Reply from Machinedramon ↑Wed Dec 25, 2019 2:46 am at Wed Dec 25, 2019 2:46 am
>
> 
so.... been trying some things....

by using the last byte of those ints getting interesting results.... now i was able to split the trees properly, even the mesh i showed before, used the first FF as a marker, then ignored a second one, as if those bytes would mix together to form 0xFFFF, kinda funny.... 
Code: Select all                f.seek(3,1)
                read = f.readByte()
                if read == 255:
                    if ffcheck == 0:
                        print("\n\t\t\t\t\tFFFF",file = mat)
                        faces.append(65535)
                        ffcheck = 1
                    else:
                        ffcheck = 0
                else:
                    ffcheck = 0
Well, if that does the trick...
## Post #13
- Username: Machinedramon
- Rank: advanced
- Number of posts: 77
- Joined date: Tue Apr 09, 2019 1:13 am
- Post datetime: 2019-12-26T10:24:06+00:00
- Post Title: Funky as hell FIs

Whew, kinda had me thinking this whole thing for long, i was pretty close, by doing an unpacking of the last byte and getting only the last bit i got where the jumps have to happen to solve the problems, now just trying to figure out what i am gonna do about the tripple jump readings, i know that i should reverse the tristrip count and jump 1 vertex.... but shit is getting really close!




thanks for the hint bigchillghost! basically started thinking it might be a bit when you mentioned that weid format.... awesome
## Post #14
- Username: Machinedramon
- Rank: advanced
- Number of posts: 77
- Joined date: Tue Apr 09, 2019 1:13 am
- Post datetime: 2019-12-26T10:45:38+00:00
- Post Title: Funky as hell FIs

a little tweak on the fi generating triangles.... and voila, normals working more or less properly, without the triangle strips and shit
## Post #15
- Username: Machinedramon
- Rank: advanced
- Number of posts: 77
- Joined date: Tue Apr 09, 2019 1:13 am
- Post datetime: 2019-12-26T11:15:38+00:00
- Post Title: Funky as hell FIs

so funnywise 3d max complaining as always while blender doing a wonderfull job at importing.... more previews....

this is working!
## Post #16
- Username: GreenTrafficLight
- Rank: beginner
- Number of posts: 28
- Joined date: Mon Apr 26, 2021 6:54 am
- Post datetime: 2022-07-10T18:39:17+00:00
- Post Title: Re: Funky as hell FIs

> Reply from Machinedramon ↑Thu Dec 26, 2019 7:15 pm at Thu Dec 26, 2019 7:15 pm
>
> 

I'm trying to write a Blender script for this game and I was wondering if you have some problem with the face orientations for the maps ( from what I've seen on your picture, it's seems they are all correctly oriented ). For my part I get weird results, even when I tried to do the way you generate your faces in my script.
## Post #17
- Username: Machinedramon
- Rank: advanced
- Number of posts: 77
- Joined date: Tue Apr 09, 2019 1:13 am
- Post datetime: 2022-07-10T19:19:09+00:00
- Post Title: Re: Funky as hell FIs

Hello there! im glad to see somebody interested in TXRD2; I think that for some time I had some ideas how to cope about it but mainly no, I have checking my backlog if I had anything regarding it, I can only say I kinda did some switch so it would count back again from 0 everytime it would jump the faces cause I think the problem lies that if you finish in a even number the next one will start using the BAC method(you know in lists that it goes ABC then BAC); so I think that if you add a loop that it corrects it to go back again into ABC and count from there on, might be fixed??? never tried, only a theory rn, if you need information regarding where to find files I might give a break down at least where the tracks are (also cars but rn fixing the faces for it has been hell, no solution I had ever found to it)
## Post #18
- Username: GreenTrafficLight
- Rank: beginner
- Number of posts: 28
- Joined date: Mon Apr 26, 2021 6:54 am
- Post datetime: 2022-07-14T00:13:14+00:00
- Post Title: Re: Funky as hell FIs

> Reply from Machinedramon ↑Mon Jul 11, 2022 3:19 am at Mon Jul 11, 2022 3:19 am
>
> 
I think the problem lies that if you finish in a even number the next one will start using the BAC method(you know in lists that it goes ABC then BAC); so I think that if you add a loop that it corrects it to go back again into ABC

Oh yeah I've done that, for some reasons some part still have the wrong face orientation, maybe it's intented or they probably have double face orientation. Not only some part of maps have double where the faces are correctly oriented, dunno why.

> Reply from Machinedramon ↑Sun May 02, 2021 12:12 am at Sun May 02, 2021 12:12 am
>
> 
to be honest at some point i kinda wanted to release the stuff more or less, though I don't want to be in any spotlight, so for now ill do the following...
the link below will work only for 1 week, aka till 8 may 2021, there will be the tracks and the textures, it needs fixing so much fun fixing what you can;

Also I was wondering, on the quote above on a other thread, you managed to extract a whole map ? How long did you take and did you managed to have textures ? Because I know maps doesn't have headers but they are splitted into thousand of files and the textures are also seperated. 

This also made me wonder if they are supposed to be hashes for the files but I didn't find anything in the archives or by debugging the game, I kinda have a theory that in the maps files, the thing you skip at the beginning probably give you informations on the material and textures, with the latter being a hash.

P.S : I'm using a custom quickbms to extract Tokyo Xtreme Racer 2 files

```
# script for QuickBMS http://quickbms.aluigi.org

quickbmsver "0.7.0"
comtype uclpack

open FDDE "TOC" 1

open FDDE "DAT.DAT" 0 EXISTS
if EXISTS == 0
    open FDDE "DAT"
endif

get FILES long 1
endian guess FILES  # x360 compatibility
get DUMMY long 1
get DUMMY long 1
get DAT_SIZE long 1

math METHOD = 0
savepos TMP 1
xmath TMP "TMP + (FILES * 0x14)"
get TOC_SIZE asize 1
if TMP u<= TOC_SIZE
    math METHOD = 1
endif

math UNKNOWN = 0

for i = 0 < FILES
    get OFFSET long 1
    math OFFSET * 0x800
	string HEX p= "%08x" OFFSET
	
	if METHOD == 1
        get DUMMY long 1
    endif
    get ZSIZE long 1
    if METHOD == 0
        get SIZE long 1
        get ZERO long 1
    else
        math ZSIZE * 0x800
        get ZERO long 1
        get SIZE long 1
    endif
	
	print "%i%, %HEX%, %SIZE%, %ZSIZE%"
	
	CallFunction DAT_EXTRACT 1
	
next i

print "%UNKNOWN% UNKNOWNS"

StartFunction DAT_EXTRACT

    string NAME p= "%08x" OFFSET
	if i != 0 && OFFSET == 0
		math UNKNOWN + 1
		#print "%ZSIZE% TEST"
	else
		# Not Compressed
		if SIZE == 0 
			log MEMORY_FILE OFFSET ZSIZE
			CallFunction CONTAINER_EXTRACT 1 0 ZSIZE NAME
		# Compressed
		else 
			clog MEMORY_FILE OFFSET ZSIZE SIZE
			CallFunction CONTAINER_EXTRACT 1 0 SIZE NAME	
		endif
    endif
	
EndFunction

StartFunction CHECK_COUNT
	# CHECK_COUNT_ARG1 : SIZE

	get COUNT long MEMORY_FILE
	If COUNT == 0
		Set COUNT long 0
	else
		xmath TMP2 "COUNT * 4"
		If TMP2 > CHECK_COUNT_ARG1
			Set COUNT long 0
		endif
		Set j long 0
		Set LASTOFFSET long 0
		Do
			Set TMP2 long 0
			get FILEOFFSET long MEMORY_FILE
			If FILEOFFSET == 0
				#print "Continue"
				Continue
			endif
			If FILEOFFSET <= LASTOFFSET
				Set COUNT long 0
				#print "Break 1"
				Break
			endif
			xmath TMP2 "COUNT * 4 + 4"
			If FILEOFFSET < TMP2
				Set COUNT long 0
				Break
			endif
			If FILEOFFSET >= CHECK_COUNT_ARG1
				Set COUNT long 0
				Break
			endif
			Set LASTOFFSET long FILEOFFSET
			Math j + 1
		While j < COUNT
	endif
			
EndFunction

StartFunction CONTAINER_EXTRACT
	# CONTAINER_EXTRACT_ARG1 : OFFSET
	# CONTAINER_EXTRACT_ARG2 : SIZE
	# CONTAINER_EXTRACT_ARG3 : NAME
	
	# GET COUNT
	GoTo CONTAINER_EXTRACT_ARG1 MEMORY_FILE SEEK_SET
	CallFunction CHECK_COUNT 1 CONTAINER_EXTRACT_ARG2
	
	# SKIP "COUNT" INTEGER
	xmath SKIP_COUNT "CONTAINER_EXTRACT_ARG1 + 4"
	GoTo SKIP_COUNT MEMORY_FILE SEEK_SET
					
	if COUNT == 0
		#print "%CONTAINER_EXTRACT_ARG3%"
		
		# GET HEADER
		GoTo CONTAINER_EXTRACT_ARG1 MEMORY_FILE SEEK_SET
		GetDString HEADER 4 MEMORY_FILE
		if HEADER == "TIM2"
			set EXTENSION string ".tm2"
		elif HEADER == "0IVX"
			set EXTENSION string ".0ivx"
		elif HEADER == "MIG."
			set EXTENSION string ".gim"
		elif HEADER == "OMG."
			set EXTENSION string ".gmo"
		elif HEADER == "‰PNG"
			set EXTENSION string ".png"
		else
			set EXTENSION string ""
		endif
		string CONTAINER_EXTRACT_ARG3 + EXTENSION
		
		log CONTAINER_EXTRACT_ARG3 CONTAINER_EXTRACT_ARG1 CONTAINER_EXTRACT_ARG2 MEMORY_FILE
	else
		Set TMP_OFFSET = 0
		for c = 1 <= COUNT				
			Get OFFSET3 long MEMORY_FILE
			if OFFSET3 != 0
				Savepos TMP_POS MEMORY_FILE
				
				# Skip offset of value 0
				if c != COUNT
					Do
						get TMP_OFFSET long MEMORY_FILE
						if TMP_OFFSET != 0
							Savepos TMP_POS MEMORY_FILE
							math TMP_POS - 4
						endif
					While TMP_OFFSET == 0
				endif
				
				# Calculate Size
				if c == COUNT 
					xmath SIZE3 "CONTAINER_EXTRACT_ARG2 - OFFSET3"
				else
					xmath SIZE3 "TMP_OFFSET - OFFSET3"
				endif
				
				# SET NAME
				string HEX_OFFSET3 p= "%08x" OFFSET3
				set NAME3 string CONTAINER_EXTRACT_ARG3
				string NAME3 + "/"
				string NAME3 + HEX_OFFSET3
												
				Math OFFSET3 + CONTAINER_EXTRACT_ARG1
				#print "%OFFSET3% | %SIZE3% | %NAME3%"
				
				CallFunction CONTAINER_EXTRACT 0 OFFSET3 SIZE3 NAME3
								
				GoTo TMP_POS MEMORY_FILE SEEK_SET
			endif
		next c
	endif
	
EndFunction
```
## Post #19
- Username: Machinedramon
- Rank: advanced
- Number of posts: 77
- Joined date: Tue Apr 09, 2019 1:13 am
- Post datetime: 2022-07-14T19:38:31+00:00
- Post Title: Re: Funky as hell FIs

> Reply from GreenTrafficLight ↑Thu Jul 14, 2022 8:13 am at Thu Jul 14, 2022 8:13 am
>
> 
 [...]

So first of all, the orientation of the faces might mean one thing, that is, that the part is some kind of reflection material(at least judging by how the faces are like that in TXR3; to make reflections in the water in rainy weather it used some kind of translucent method for the faces on the road and other surfaces)

Also regarding the maps, yes I did manage to extract them, research had been since long. So here is the outtake on how the hierarchy of the files work, maps and cars don't share the same header/filetype; Texture are TIM2 for all Genki games in PS2, although, not all the versions do have the TIM2 header, usually maps do follow the following type of structure:

_________________
akagi_0
c33
c34

akagi_1
c35 collider
c36 skybox
c37 global
c38-c5b checkpoints
c5c local 0
c96 local 1
d04 local 2
d39 local 3
d50 end
_________________

so here the first thing, each of the files has a global texture folder(it has all the files for the full track/weather); 

Structurewise you have first 2 files that i don't really know what they are, they might be the minimap of the track or something, then a colider mesh which looks pretty much like some geometry, the skybox of the map, the global texture, the checkpoints are separated from the track(probably because of layouts in the track) then the locals(tracks are separated in meshes that are renderable by buffers to send to the render engine, those are also packed in bigger containers with special qualities like what the local textures are, which mostly are banners and adds, and also the animation textures of the local chunk). the end file here is just a way for me to mark where the last part of that local is, depending on how many weathers the track in question has, you will see more versions of that track....




and yes i know zao weathers i didn't bother to fully parse, i was lazy xD but you can kinda pinpoint the starts and finish by file type and file size(globals be big, 0iv ones be checkpoints, texture containers are in .dat format). Also, to process the texture packs, you basically have to cut the file into the containers inside and rename to .tm2 to be able to unpack using the Noesis TIM2 unpacker.

the structure of those texture packs is count of files + files offset * the count of them(pretty straight forward)


i could add also the code from my very latest work on the script, but its really complicated and probably spaghetti code, if you wanna have a read, go for it

```
import sys
import os
import struct
import time
from glob import glob
#from nines import *
#f = mrp.get_bfile()

print("IVX Script rev 0.77\n"+
      "currently suported; select type of file:\n\t"+
      "1-TXR0\t\t"          +"V/F/U\t;Flipped Y cars\n\t"+
      "2-TXRD1/KB1\t"   +"V/F/U\n\t"+
      "3-TXR3\t\t"          +"V/F/U\n\t"+
      "4-TXRD1.5/KB2\t" +"V/F/U\n\t"+
      "5-RBC1GP\t\t"      +"V/F*/U\t;faces broken cars\n\t"+
      "6-TXRD2/KB3\t"    +"V/U\t;faces broken cars/tracks")
current = input()
#loop = 0
while True:
    try:
        current = int(current)
        if current < 1 or current > 6:
            print("input a correct number")
            current = input()
        else:
            break
    except:
        print("input a number")
        current = input()
   
print("current choice = " + str(current))

#start variables
txrd2_track = 0
c1_track = 0
manual_txrz_car = 0

if current == 1:
    #ask for car/flip Y
    print("is it a car? Answer Y/N")
    answer = input()
    while answer not in ["y","n","Y","N"]:
        answer = input()
    if answer == "y" or answer == "Y":
        manual_txrz_car = 1
    else:
        pass
elif current == 5:
    print("is it a track? Answer Y/N")
    answer = input()
    while answer not in ["y","n","Y","N"]:
        answer = input()
    if answer == "y" or answer == "Y":
        c1_track = 1
elif current == 6:
    print("is it a track? Answer Y/N")
    answer = input()
    while answer not in ["y","n","Y","N"]:
        answer = input()
    if answer == "y" or answer == "Y":
        txrd2_track = 1

#folder or file?
print("is it a folder or a file you want to process?"+
      "\t1 - File"+
      "\t2 - Folder")
answer_folderfile = input()
while True:
    try:
        answer_folderfile = int(answer_folderfile)
        if answer_folderfile < 1 or answer_folderfile > 2:
            print("input a correct number")
            answer_folderfile = input()
        else:
            break
    except:
        print("input a number")
        answer_folderfile = input()

#files parse
print("input the direction")
files = []
if answer_folderfile == 1:
    file = input()
    while True:
        try:
            with open(file, "rb"):
                break
        except:
            print("file does not exist, input a correct file")
            file = input()
    files.append(file)

elif answer_folderfile == 2:
    folder = input()
    while True:
        try:
            files = glob(folder+"\\*")
            break
        except:
            print("folder does not exist, input a correct folder")
            folder = input()
print("files to process:\n",files)

#output folder
print("input output folder:")
out_folder = input()
if os.path.exists(out_folder) is True:
    print("folder exists")
else:
    print("folder does not exist, create? Y/N")
    create_folder = input()
    while create_folder not in ["y","n","Y","N"]:
        print("incorrect answer, try again:")
        create_folder = input()
    if create_folder == "y" or create_folder == "Y":
        os.mkdir(out_folder)

#sys.exit("testing")




#curfile = ""#E:\\Downloads\\ModelResearcherPro\\Nueva carpeta\\txr3\\c1\\2022\\txr3\\cars\\00000110.nfc
#obj_name = curfile

#f = lefile = open(curfile,"rb")
#   IVX File format Script
#   Revision 0.76
#   date 21/03/22
#   Author: Nines


#jump to line: 720
#--------------------- here missing files in next post-----------------------
#sys.exit("end of header")



#start of file?; implement file/folder system
tim2_count = 0

for i in range(len(files)):
    curfile = files[i]
    f = lefile = open(curfile,"rb")
    obj_name = curfile
    filename_1 = curfile.split("\\")[-1]
    file_name = filename_1.split(".")[0]
    print(file_name)
    #sys.exit()

    
    #0IVX Script rewrite
    test = [rByte() for i in range(4)]
    f.seek(0,2)
    eof = tell()
    f.seek(0)

    file_type = "no_type"
    ivx = [0x30, 0x49, 0x56, 0x58]

    offs = []
    if test != ivx: #0ivx exclude, toc
        num_files = rInt()
        offs = [rInt() for i in range(num_files)]
        txrz_tracks = 0
        #second test for nested files
        #move to offs 1 and test for 3
        f.seek(offs[1])
        if rInt() == 3:
            new_offs = []
            print([hex(i) for i in offs])
            #nested, create new ofsets using accumulated offset? + 0x30
            for i in range(len(offs)):
                f.seek(offs[i]+4)
                constant = offs[i]
                #print(hex(offs[i]),[rInt() for i in range(3)])
                new_offs += [rInt()+constant for i in range(3)]
            offs = new_offs
        #print(offs)
    else:
        file_type = "txrz_tracks"
        #print(file_type)
        txrz_tracks = 1
        for i in range(int(eof/16)):
            f.seek(16*i)
            test = [rByte() for i in range(4)]
            if test == ivx:
                offs.append(f.tell()-4)
        #offs = [0]
    f.seek(0)
    print(len(offs),[hex(i)for i in offs])
    #sys.exit()

    meshes = []
    #meshlist = {}
    flag_counter = []
    counter = 0

    #---------------------------------------------TXRD2-------------------------------------------------
    #is this a txrd2 Track file? 0 = no, 1 = yes
    #txrd2_track = 0

    if txrd2_track == 1:
        materials_header = [rInt() for i in range(4)]
        #print(materials_header)
        materials_toc = [[rInt() for i in range(4)]for i in range(materials_header[0])]
        offs = [tell()]
    #---------------------------------------------------------------------------------------------------
    #c1_track = 0
    #manual_txrz_car = 0
    #---------------------------------------------------------------------------------------------------

    debug_flag = 0
    render_last = 0
    debug_counts = [1,1,1] #super_cont, part, chunk

    #print(len(offs))

    offs.append(eof)
    #print(f.tellHex())
    #sys.exit("line 791")

    for i in range(len(offs)-1):#mesh_render):#num_files
        f.seek(offs[i])
        print("reading file at ",tellh())
        curfile = i
        c1gp = [49,50,50]
        txrd2 = [49,49,49] #cars only

        #if txrd2_track == 0:
        #testing for file type
        #for i in range(1):
        if txrd2_track == 0:
            test = [rByte() for i in range(16)]
            if test == [0 for i in range(16)]:
                #zero escape loop
                break
            else:
                f.seek(-16,1)
            ivx = [rByte() for i in range(8)]
            zero = [rByte() for i in range(8)]
            ldmx = [rByte() for i in range(8)]
            mron = [rByte() for i in range(8)]
            filetype = [ivx, zero, ldmx, mron]

            file_type = 0

            #break loop
            if ivx == [0x30, 0x49, 0x56, 0x58, 0x30, 0x30, 0x2e, 0x31]:#true
                file_type = 1
            elif ivx[:6] == [0x54, 0x49, 0x4D, 0x32, 0x04, 0x01]:
                file_type = 2
                print("TIM2 file found, dumping it to file.tm2 in output folder")
                #tim2
                #sys.exit("TIM2 format not yet implemented")
            else:
                print("offset not matching regex, not a TIM2 nor 0IVX format, probably end file(game engine config?), skiping it")
                file_type = 3
                #break

            #if file_type == 1:
            
            #if txrd2_track == 0:
            #games struct
            file_struct = [ivx[-1],ldmx[-1],mron[-1]]
            #print(file_struct)

                
                
            #header structure
            pointers = [rInt() for i in range(4)]
            #print(f.tellHex())
            count_sect_2 = pointers[0]
            count_of_rep = pointers[1]
            size_sect1 = pointers[3]
            #print(hex(size_sect1))

            #sect 1, i dont know what this does it only breaks compatibility, skip for now
            sect1_data = [rByte() for i in range(size_sect1)]


            #sect 2
            counters = [[rInt() for i in range(4*3) for i in range(count_sect_2)]]
            #test for CC
            if(counters[0][-1] == 3435973836) and file_type != "txrz_tracks": #probably txrz car
                #indicate here if the Y shall be corrected; txrz cars format
                print("flip normals plz?")
                correct = 0
                if correct == 1 or manual_txrz_car == 1:
                    file_type = "txrz_car"
                    
                #print(f.tellHex())
        else:
            file_struct = [0,0,0]
        some_counter = 0
        break_flag = 0
            
        #supercontainer
        super_cont_rep = 130 #130
        if txrd2_track == 1:
            super_cont_rep = materials_header[0]

        try:
        #for i in range(1):
            for i in range(super_cont_rep):#130):
                if tell()+0x100 > eof:
                    break
                if tell() >= offs[curfile+1]:
                    break_flag = 1
                #print(i, f.tellHex())
                #if file_type == "txrz_tracks":
                #check for position
                if curfile+0x100 < len(offs)-1: #check agaist next position
                    print("working?", offs[curfile+1]+0x100)
                    if tell() >= offs[curfile+1]:
                        break_flag = 1
                if break_flag == 1: ############################################################break
                    break
                super_container = i
                pos_super_cont = tellh()
                #print("super_container number "+str(i),f.tellHex(),some_counter)

                if txrd2_track == 0:
                    #matrix
                    #print(f.tellHex())
                    matrix_1 = [rInt() for i in range(8)] + [fint() for i in range(12)]
                    locator_pos = [matrix_1[8],matrix_1[9],matrix_1[10]]
                    if matrix_1[0] == 0: #matrix 2 read if needed
                        matrix_2 = [rInt() for i in range(8)] + [fint() for i in range(12)]
                    #override
                    #locator_pos = [0,0,0]
                    #print(f.tellHex())
                            
                    #sect a; start here for txrd2
                    #counter for reps in container?
                    values_cont_a = [rInt() for i in range(4)]
                    cont_len = values_cont_a[3]
                    #print(cont_len)
                    #som positioning a
                    pos_cont_a = [[[fint() for i in range(3)],fint()] for i in range(2)]

                else:
                    locator_pos = [0,0,0]
                    cont_len = materials_header[0]



                for i in range(cont_len):
                    cur_part = i
                        
                    #print("part start",f.tellHex())
                    some_counter = some_counter + 1
                    #print(cur_part)
                    if txrd2_track == 0:
                        #from here repeteated
                        #fic = 0
                        #sect b
                        values_cont_b = [rShort() for i in range(8)]
                        #som positioning b
                        pos_cont_b = [[[fint() for i in range(3)],fint()] for i in range(2)]
                        #print(f.tellHex())

                        #common cont
                        short_values = [[rShort() for i in range(8)]for i in range(4)]
                        if file_struct == txrd2:
                            #more correction
                            f.seek(0x30,1)

                    interesting = [rInt()for i in range(3)]+[fint()]
                    float_values = [[fint() for i in range(4)]for i in range(2)]
                    #print(f.tellHex(), interesting)
                    #sys.exit()

                    part_repeats = interesting[1]
                    size_part = tell() + (interesting[2]*16)
                    super_verts = []
                    super_uvs = []
                    super_normals = []
                    super_data = []
                    super_fis = []
                    tic_toc = 0
                    curfi = -1
                    #if txrd2_track == 1:
                    #    curfi = 1
                    if c1_track == 1:
                        curfi = 0
                        c1_extra = 0
                    facestri = []
                    #print(part_repeats)
                    #print(f.tellHex())
                    #cur_part = "test"
                    #if debug_counts[2] == 0 and cur_part > debug_counts[1]-1:
                    #    if render_last == 1:
                    #        mrp.render(last_mesh)
                    #    else:
                    #        mrp.render(meshes)
                    #    sys.exit("end of render debug")
                            
                        
                    for i in range(part_repeats):#loop for data
                        #cur_part = i
                        chunk_part = i
                        #print("part", cur_part,"chunk",chunk_part,f.tellHex())#

                        if debug_flag == 1 and chunk_part == debug_counts[2]-1 and cur_part == debug_counts[1]-1 and super_container == debug_counts[0]-1:
                            if 0 in debug_counts:
                                debug = 0
                            else:
                                debug = 1
                            #print(f.tellHex())
                        else:
                            debug = 0
                            
                        fic = len(super_verts)
                        #some_counter = some_counter + 1
                        #start of mesh_data
                        start_off = tell()
                        init_data = [rShort()for i in range(6)]+[rInt()]
                        size = init_data[0] * 16 + 16
                        vc_alpha = init_data[-1]
                        uvs = []
                        fis = []
                        normals = []
                        fis_6a = []

                        #header flag
                        header_flag = [rByte()for i in range(4)]
                        #print(f.tellHex(),header_flag)
                        if header_flag == [2,2,0,1] or header_flag == [4,4,0,1]:#!=
                            #sys.exit("no header flag?")
                            sub_flag_header = [rByte()for i in range(4)]
                            if sub_flag_header[3] != 0x6c:
                                sys.exit("sub_flag_header not a position array?", tellh())
                            #print("header_flag = ", sub_flag_header)
                            header_pos_coords = [[[fint() for i in range(3)],fint()] for i in range(sub_flag_header[2])]
                            #print(f.tellHex())

                            #start of data
                            data_flag = [rByte()for i in range(4)]
                            if data_flag != [4,1,0,1]:
                                sys.exit("data flag error: " + str(tellh()) + str(hex(data_flag)))
                        else:
                            sys.exit(("no header flag?", header_flag, tellh(), super_cont_rep, cont_len, part_repeats))
                        #sub_flag_data = [f.readByte()for i in range(4)]


                        #check variables
                        verts_check = 0
                        uvs_check = 0
                        fis_check = 0

                        #for i in range(3):
                        while(tell() < (start_off + size)):
                            sub_flag_data = [rByte()for i in range(4)]
                            rep = sub_flag_data[2]
                                
                            if sub_flag_data[3] == 0x68 and verts_check == 0:
                                #verts 3 times float
                                verts_check = 1
                                #print(f.tellHex())
                                if sub_flag_data[3] not in flag_counter:
                                    flag_counter.append(sub_flag_data[3])
                                verts = []
                                for i in range(rep):
                                    #verts = [[f.readFloat()+ locator_pos[j] for j in range(3)] for i in range(rep)]
                                    vert = [fint()+ locator_pos[j] for j in range(3)]
                                    if debug == 1 and False:
                                        print(vert)
                                    if file_type == "txrz_tracks" or file_type == "txrz_car":
                                        vert[1] = vert[1] * (-1)
                                    verts.append(vert)

                            elif sub_flag_data[3] == 0x64 and uvs_check == 0:
                                #uvs 2 time float
                                uvs_check = 1
                                cur_uvs = []
                                if sub_flag_data[3] not in flag_counter:
                                    flag_counter.append(sub_flag_data[3])
                                for i in range(rep):
                                    uv = [fint() for i in range(2)]
                                    #f.seek(-8,1)
                                    #uv_data = 
                                    uvs.append(uv)
                                    #if debug == 1:
                                    #    #print([(format(i,'b').zfill(8)) for i in data])
                                    #    print(i, f.tellHex(), [[hex(i) for i in uvs])
                                    
                            elif sub_flag_data[3] == 0x65 and uvs_check == 0:
                                #uvs
                                uvs_check = 1
                                uvs = []
                                if sub_flag_data[3] not in flag_counter:
                                    flag_counter.append(sub_flag_data[3])
                                #uvs = [[f.readShort() for i in range(2)] for i in range(rep)]
                                for i in range(rep):
                                    uv_data = [rByte() for i in range(4)]
                                    uvs.append(uv_data)
                                    if debug == 1 and False:
                                        #print([(format(i,'b').zfill(8)) for i in uv_data])
                                        #print(i, f.tellHex(), [hex(i) for i in uv_data])
                                        pass
                                #print(uvs)

                            elif sub_flag_data[3] == 0x6E and fis_check == 0: #txrd2 tracks faces format
                                #pseudonormals
                                fis_check = 1
                                if sub_flag_data[3] not in flag_counter:
                                    flag_counter.append(sub_flag_data[3])
                                #counter = 0
                                container_data = []
                                #som_jumps = []
                                #data = [[f.readByte() for i in range(4)]for i in range(rep)]
                                count_flags = 0
                                for i in range(rep):
                                    data = [rByte() for i in range(4)]
                                    #if data == [0x8e,0x8e,0x8e,0xFF]:
                                    #    print(super_container, cur_part, chunk_part, i)
                                    if debug == 1:# and False:
                                        #print([(format(i,'b').zfill(8)) for i in data])
                                        #print(i, f.tellHex(), [hex(i) for i in data])
                                        flag_data =  data[:3]
                                        divider = min(flag_data)
                                        flag_array = [i%divider for i in flag_data]
                                        if i == 0:
                                            print_flag = 1
                                            comp = flag_array
                                        if comp == flag_array:
                                            count_flags = count_flags + 1
                                            if i != 0:
                                                print_flag = 0
                                        else:
                                            count_flags = 1
                                            print_flag = 1
                                        comp = flag_array
                                        #print(i, "".join([(format(i,'b').zfill(8))for i in data]))
                                        #print([hex(cosa) for cosa in data],[hex(i)for i in flag_array],print_flag,count_flags)
                                    container_data.append(data)
                                #    if i == 0:
                                #        comp = data
                                #    if comp == data:
                                #        jump = 0
                                #        #som_jumps.append(0)
                                #    else:
                                #        jump = 1
                                #        #som_jumps.append(1)
                                #    som_jumps.append(data[2]%2)
                                #    comp = data
                                    #print(data[2]%2,jump)
                                #print(container_data,som_jumps)
                                #print([[hex(j) for j in container_data[i]] for i in range(len(container_data))])
                                #print(uvs)
                                if txrd2_track == 1 or c1_track == 1: #here the new check
                                    if txrd2_track == 1:
                                        jump_array = [container_data[i][-1]%2 for i in range(len(container_data))]
                                        jump_array2 = [(bin(container_data[i][-1]))for i in range(len(container_data))]
                                        ffcheck = 0
                                        for i in range(len(jump_array)):
                                            binary = jump_array[i]
                                            curfi = curfi + 1
                                            facea = curfi - 2
                                            faceb = curfi - 1
                                            facec = curfi
                                            if binary == 1:
                                                if ffcheck == 0:
                                                    ffcheck = 1
                                            else:
                                                if (i % 2) == 0:
                                                    facestri.append((facea,faceb,facec))
                                                else:
                                                    facestri.append((facea,facec,faceb))
                                                ffcheck = 0
                                        super_fis = super_fis + fis
                                        if debug == 1:
                                            pass
                                            #print(facestri)
                                    elif c1_track == 1:
                                    #elif debug == 1:
                                        #print("c1 script",len(container_data))
                                        #okay this is not simple... 2 cases, 4 and 6
                                        #for i in range(len(container_data)) #needs to be ended
                                        try:
                                            fis = []
                                            ffcheck = 0
                                            countcheck = 0
                                            j = 0
                                            #for i in range(len(container_data-2)):
                                            while j < len(container_data):
                                                
                                                #if container_data[j] == [0x1f,0x1f,0x20,0xff] or len(container_data)-j == 6: #6 element jump
                                                
                                                if len(container_data) > j+6:
                                                    if container_data[j][0] < 0x34:
                                                        fis = fis + [0xFFFF, j, j+1, j+2, j+3, j+4, j+5, 0xFFFF]
                                                        j = j + 6
                                                    else: #4 element
                                                        fis = fis + [0xFFFF, j, j+1, j+2, j+3, 0xFFFF]
                                                        j = j + 4
                                                elif len(container_data) > j+4:
                                                    fis = fis + [0xFFFF, j, j+1, j+2, j+3, 0xFFFF]
                                                    j = j + 4
                                                else:
                                                    for i in range(len(container_data) - j):
                                                        fis.append(j)
                                                        j = j + 1
                                                #else: #4 element
                                                #    fis = fis + [0xFFFF, j, j+1, j+2, j+3, 0xFFFF]
                                                #    j = j + 4
                                                
                                            if debug == 1:
                                                pass
                                                #print(fis)
                                        except:
                                            fis = []
                                            flag_faces = 0
                                            counter_faces = 0
                                            swith = 0
                                            for i in range(len(container_data)):
                                                if(container_data[i] == [0x1f, 0x1f, 0x20, 0xFF]):
                                                    counter_faces = counter_faces + 1
                                                #cur = i
                                                cur = counter_faces
                                                #print(cur)
                                                if cur%4 == 0:
                                                    if i+4 < len(container_data):
                                                        fis.append(0xFFFF)
                                                        fis.append(i)
                                                    else:
                                                        fis.append(i)
                                                else:
                                                    fis.append(i)
                                                counter_faces = counter_faces + 1

                                            super_fis = super_fis + fis
                                        #print(super_fis)

                            elif sub_flag_data[3] == 0x6D:
                                #color  8 bytes? probably normals
                                if sub_flag_data[3] not in flag_counter:
                                    flag_counter.append(sub_flag_data[3])
                                for i in range(rep):
                                    #color_data = [f.readShort() for i in range(4)]
                                    elements = [rShort() for i in range(4)]
                                    flip = []
                                    #method
                                    for i in elements:
                                        number = i
                                        #result = (int(number/0x8000) * -1) * ((number%0x8000)/0x8000)
                                        if i >= 0x8000:
                                            result = ((number%0x7FFF)/0x7FFF) * 0.1 * -1
                                        else:
                                            result = ((number%0x7FFF)/0x7FFF) * 0.1# * -1
                                        #print(result)
                                        flip.append(round(result,3))
                                    #print(elements,flip)
                                    normals.append(flip[:3])

                            elif sub_flag_data[3] == 0x6A: #3 bytes + difference
                                #color 4 bytes?
                                if sub_flag_data[3] not in flag_counter:
                                    flag_counter.append(sub_flag_data[3])
                                data_6a = []
                                fis_6a = []
                                normals = []
                                for i in range(rep):
                                    color_data = [rByte() for i in range(3)]
                                    last_element = int(color_data[0]/0x80)
                                    data_6a.append(last_element)
                                    maths = [(int(i/0x80)*(-1))+((i%0x80)/0x80)for i in color_data]
                                    normals.append(maths)
                                    if i == 0:
                                        comp_fi = last_element
                                    if last_element == comp_fi:
                                        fis_6a.append(i)
                                    else:
                                        fis_6a.append(0xFFFF)
                                        fis_6a.append(i)
                                    if debug == 1:
                                        pass
                                        #print(i, [(format(i,'b').zfill(8))for i in color_data],(int(color_data[0]/0x80)))
                                        #print(i,[hex(i) for i in color_data],maths)#hex(int((color_data[0]+color_data[1]+color_data[2]))))
                                    comp_fi = last_element
                                #print(fis_6a)
                            elif sub_flag_data[3] == 0x62:
                                #FF section 1 byte elements
                                if sub_flag_data[3] not in flag_counter:
                                    flag_counter.append(sub_flag_data[3])
                                for i in range(rep):
                                    color_data = f.readByte()

                            else:
                                #pass
                                if sub_flag_data[3] > 0x5f and sub_flag_data[3] < 0x70:
                                    if sub_flag_data[3] not in flag_counter:
                                        flag_counter.append(sub_flag_data[3])
                                    #pass
                                    #print("current flag not handled, flag: " + str(hex(sub_flag_data[3])) + ", offset " + str(f.tellHex()))


                        if file_type == "txrz_tracks":
                            fis = [] #autogen the faces, like txr3
                        #autogen fis
                        #print(len(fis))
                        if(len(fis)) < 3 and len(facestri) == 0 and len(fis_6a) == 0:
                            #print("autogen??")
                            #last item in super_fis
                            if len(super_fis) != 0:
                                extra = 1
                            else:
                                extra = 0
                            last_item = 0
                            for i in range(len(super_fis)):
                                if super_fis[i] > last_item and super_fis[i] != 65535:
                                    last_item = super_fis[i]
                            #fis = [i+len(verts) for i in range(len(verts))] + [0xFFFF]
                            fis = [i+last_item+extra for i in range(len(verts))] + [0xFFFF]
                            #fis.append(0xFFFF)
                            super_fis = super_fis + fis
                        #print(super_container, cur_part, chunk_part)
                        if len(uvs) == 0:
                            #print(super_container, cur_part, chunk_part, len(uvs),len(super_uvs))
                            uvs = [[0,0]for i in range(len(verts))]
                        if len(normals) == 0:
                            normals = [[0,0,0] for i in range(len(verts))]
                        try:
                            if len(fis_6a) > 3:
                                fis = fis_6a
                        except:
                            pass
                        try: #conversion to faces; needs algorithm for tristrip
                            if len(fis) == 0 and len(fis_6a) == 0 and len(facestri) != 0:
                                faces = facestri
                            elif len(facestri) == 0 and len(fis) == 0 and len(fis_6a) != 0:
                                faces = fis_6a
                            elif len(fis_6a) == 0 and len(facestri) == 0 and len(fis) != 0:
                                faces = fis
                        except:
                            pass
                        #print(fis, facestri)
                        #sys.exit("fin")
                        f.seek(start_off + size)
                        super_verts = super_verts + verts
                        super_uvs = super_uvs + uvs
                        super_normals = super_normals + normals
                        #print(len(super_uvs))
                        if c1_track == 1:
                            #c1 render each chunk
                            curmesh = file_name + "_file_" + str(curfile) + "_part_" + str(super_container)+ "_mesh_" + str(cur_part) + "_chunk_" + str(chunk_part)
                            #print(curmesh+"************************************************")
                            counter = counter + 1
                            #if counter == 36:
                            #    print("this one is the one that broke ************")
                            #    print(f.tellHex(), pos_super_cont,hex(start_off + size),hex(size_part))
                            #mrp.create_mesh(curmesh)
                            #mesh = mrp.get_mesh(curmesh)
                            #mesh.set_vertices(verts)
                            #mesh.set_faces(fis,fm="TStripFF")
                            #mesh.set_uvs_indices(faces,fm="TStripFF")
                            #matt = mrp.create_material(mat)
                            #if matex:
                            #    exec(matex)
                            #mesh.set_material(matt)
                            #if len(normals) != 0:
                                #mesh.set_normals(normals)
                            #mrp.render(curmesh)
                            #mrp.view_uvs(curmesh)
                            #mrp.print_mesh(curmesh)
                            #meshes.append(curmesh)
                            #mrp to nines-------------------
                            #meshlist[curmesh] = {}
                            create_mesh(curmesh)
                            meshlist[curmesh]["verts"] = verts
                            meshlist[curmesh]["faces"] = faces
                            meshlist[curmesh]["uvs"] = uvs
                            meshlist[curmesh]["normals"] = normals
                            #meshlist[curmesh][material] = material
                            #meshlist[curmesh][name] = name
                            #meshlist[curmesh][texture] = texture
                            #mesh_class = mesh()
                            #mesh_class.name = curmesh
                            #mesh_class.verts = verts
                            #mesh_class.faces = fis
                            #mesh_class.normals = normals
                            #print(meshlist)
                            last_mesh = curmesh
                            if debug_flag == 1 and super_container == debug_counts[0]-1 and cur_part == debug_counts[1]-1 and chunk_part == debug_counts[2]-1:
                                if render_last == 1:
                                    mrp.render(last_mesh)
                                else:
                                    mrp.render(meshes)
                                print(meshes)
                                print_obj(meshes,file_name)
                                sys.exit("end of render debug")
                    f.seek(16,1)
                    #print(f.tellHex())

                    #print(normals)
                    #print(super_fis)
                    #----end of data catch-----
                    #super_fis = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 65535, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 65535]

                    #parts render
                    if c1_track == 0:
                        curmesh = file_name + "_file_" + str(curfile) + "_part_" + str(super_container)+ "_mesh_" + str(cur_part)
                        #print(curmesh)
                        counter = counter + 1
                        #if counter == 36:
                        #    print("this one is the one that broke ************")
                        #    print(f.tellHex(), pos_super_cont,hex(start_off + size),hex(size_part))
                        #print(super_fis)
                        #mrp.create_mesh(curmesh)
                        #mesh = mrp.get_mesh(curmesh)
                        #mesh.set_vertices(super_verts)
                        #mesh.set_normals(super_normals)
                        if txrd2_track == 1:
                            #mesh.set_faces(facestri)
                            pass
                        else:
                            #mesh.set_faces(super_fis,fm="TStripFF")
                            faces = super_fis
                        #mesh.set_uvs_indices(faces,fm="TStripFF")
                        #matt = mrp.create_material(mat)
                        #if matex:
                        #    exec(matex)
                        #mesh.set_material(matt)
                        #mesh.set_normals(normals)
                        #mrp.render(curmesh)
                        #mrp.view_uvs(curmesh)
                        #mrp.print_mesh(curmesh)
                        meshes.append(curmesh)
                        #mrp to nines-------------------
                        #meshlist[curmesh] = {}
                        create_mesh(curmesh)
                        meshlist[curmesh]["verts"] = super_verts
                        meshlist[curmesh]["faces"] = faces
                        meshlist[curmesh]["uvs"] = super_uvs
                        meshlist[curmesh]["normals"] = super_normals
                        #meshlist[curmesh][material] = material
                        #meshlist[curmesh][name] = name
                        #meshlist[curmesh][texture] = texture
                        #mesh_class = mesh()
                        #mesh_class.name = curmesh
                        #mesh_class.verts = verts
                        #mesh_class.faces = fis
                        #mesh_class.normals = normals
                        #print(meshlist)
                        #mrp.render(curmesh)
                        last_mesh = curmesh
                        if debug_flag == 1 and super_container == debug_counts[0]-1 and cur_part == debug_counts[1]-1 and chunk_part == debug_counts[2]-1:
                            #if render_last == 1:
                                #mrp.render(last_mesh)
                            #else:
                                #mrp.render(meshes)
                            print(meshes)
                            print_obj(meshes)
                            sys.exit("end of render debug")
                    
                    #print(tic_toc)
                    #print(f.tellHex(),hex(start_off + size),hex(size_part))
        except:
            print("process broke at: " + str(super_container) + " " + str(pos_super_cont))

    elif file_type == 2:
        #tim2 dump file goes here
        current_off = offs[curfile]
        size = offs[curfile+1] - offs[curfile]
        print("tim2 file offset and size = ", hex(current_off), hex(size))
        #file create and dump
        f.seek(current_off)
        buffer = rbyte(size)
        tim2_curfile = open(out_folder + file_name + "_" + str(tim2_count)+ ".tm2",'w+b')
        tim2_count += 1
        tim2_curfile.write(bytearray(buffer))
        tim2_curfile.close()
            
            
    #print(part_11_1)
    #mrp.render(meshes)
    print_obj(meshes,file_name)
    print("meshes found:",meshes)
    flags_print = [hex(i) for i in flag_counter]
    print("flags found:",flags_print)
    sys.exit("end of scritp")

```
## Post #20
- Username: Machinedramon
- Rank: advanced
- Number of posts: 77
- Joined date: Tue Apr 09, 2019 1:13 am
- Post datetime: 2022-07-14T19:39:46+00:00
- Post Title: Re: Funky as hell FIs

Nines.py stuff

```
#--------------------------------------------------------------------------------------------------------------  
#variables
endian = "little"
endian2 = '<'
roundvalue = 5
#obj_folder = "E:\\Downloads\\ModelResearcherPro\\Nueva carpeta\\txr3\\c1\\2022\\_obj\\"
if out_folder[-2:] != "\\":
    out_folder += "\\"
obj_folder = out_folder

def curtime():
    return (time.strftime("%a, %d %b %Y %H:%M:%S %z"))

#obj print missing
def print_obj(array,filename):
    obj_name = filename#change please
    ext = ".obj"
    if type(array) != list:
        print("please enter an array list???")
    #first of all lets create a file
    with open(obj_folder+obj_name+ext,"wt") as obj_file:
        #comment section
        print("# " + obj_name + '\n' + "# time: " + curtime(), file = obj_file)
        #print("# " + obj_folder + obj_name + ".obj" + "\n", file = obj_file)
        print("\n" + obj_name + ".mtl", file = obj_file)
        akku = 0
        for i in array:
            thing = i
            #arrays
            verts = meshlist[thing]["verts"]
            faces = meshlist[thing]["faces"]
            #print(faces)
            if type(faces[0]) == int:
                buffer = []
                counter = 0
                for i in range((len(faces))-2):
                    a = faces[i]
                    b = faces[i+1]
                    c = faces[i+2]
                    if a == 65535 or b == 65535 or c == 65535:
                        counter = 0
                    else:
                        if counter%2 == 0:
                            #abc
                            face_format = [a,b,c]
                        else:
                            #acb
                            face_format = [a,c,b]
                        buffer.append(face_format)
                        counter = counter + 1
                faces = buffer
            #print(faces)
            uvs = meshlist[thing]["uvs"]
            normals = meshlist[thing]["normals"]
            #strings
            material = meshlist[thing]["material"]
            texture = meshlist[thing]["texture"]
            print("\n" + "\n" + "# " + thing + '\n', file = obj_file)
            print("# " + thing + " Vertices " + str(len(verts)) + '\n', file = obj_file)
            for i in range(len(verts)):
                print("v  " + str(round(verts[i][0],roundvalue)) + " " + str(round(verts[i][1],roundvalue)) + " " + str(round(verts[i][2],roundvalue)), file = obj_file)
            print('\n', file = obj_file) #add spacing
            if len(uvs) != 0:
                print("# " + thing + " Uvs " + str(len(uvs)) + '\n', file = obj_file)
                for i in range(len(uvs)):
                    print("vt  " + str(round(uvs[i][0],roundvalue)) + " " + str(round(uvs[i][1]*(-1),roundvalue)), file = obj_file)
            if len(normals) != 0:
                print("# " + thing + " Normals " + str(len(normals)) + '\n', file = obj_file)
                for i in range(len(normals)):
                    print("vn  " + str(round(normals[i][0],roundvalue)) + " " + str(round(normals[i][1],roundvalue)) + " " + str(round(normals[i][2],roundvalue)), file = obj_file)
            print('\n', file = obj_file) #add spacing
            if len(faces) != 0:
                #needs to add sequences for uvs and normals
                print("# " + thing + " Faces " + str(len(faces)) + '\n', file = obj_file)
                #material
                if len(material) != 0:
                    print("usemtl " + str(material), file = obj_file)
                else:
                    #default material
                    print("usemtl " + "default_material", file = obj_file)
                #groups/objects/smoothing groups, this needs more research
                print("g " + str(thing) + "\n", file = obj_file)
                max_value = 0
                for i in range(len(faces)):
                    if max(faces[i]) > max_value:
                        max_value = max(faces[i])
                    if len(uvs) != 0 and len(normals) != 0:
                        print("f  " + str(faces[i][0]+1 + akku) + "/" + str(faces[i][0]+1 + akku) + "/" + str(faces[i][0]+1 + akku) + " " + str(faces[i][1]+1 + akku) + "/" + str(faces[i][1]+1 + akku) + "/" + str(faces[i][1]+1 + akku) + " " + str(faces[i][2]+1 + akku) + "/" + str(faces[i][2]+1 + akku) + "/" + str(faces[i][2]+1 + akku), file = obj_file)
                    elif len(normals) != 0 and len(uvs) == 0:
                        print("f  " + str(faces[i][0]+1 + akku) + "/" + str(faces[i][0]+1 + akku) + " " + str(faces[i][1]+1 + akku) + "/" + str(faces[i][1]+1 + akku) + " " + str(faces[i][2]+1 + akku) + "/" + str(faces[i][2]+1 + akku), file = obj_file)
                    elif len(uvs) != 0 and len(normals) == 0:
                        print("f  " + str(faces[i][0]+1 + akku) + "/" + str(faces[i][0]+1 + akku) + " " + str(faces[i][1]+1 + akku) + "/" + str(faces[i][1]+1 + akku) + " " + str(faces[i][2]+1 + akku) + "/" + str(faces[i][2]+1 + akku), file = obj_file)
                    else:
                        print("f  " + str(faces[i][0]+1 + akku) + " " + str(faces[i][1]+1 + akku) + " " + str(faces[i][2]+1 + akku), file = obj_file)
                akku = akku + max_value + 1
                



meshlist = {}
def create_mesh(name):
    meshlist[name] = {}
    meshlist[name]["verts"] = []
    meshlist[name]["faces"] = []
    meshlist[name]["uvs"] = []
    meshlist[name]["normals"] = []
    meshlist[name]["material"] = ""
    meshlist[name]["name"] = name
    meshlist[name]["texture"] = ""
    


#create_mesh("cosa")
#meshlist["cosa"]["verts"] = [(i,i+1,i+2) for i in range(0,10)]
#print(meshlist)
#cosa = mesh()
#cosa.verts = [(i,i+1,i+2) for i in range(0,10)]
#exec("print(\"# Vertices \" + str(len(" + "cosa" + ".verts)))")
#print(len(cosa.verts))
#print_obj(["cosa"])

#sys.exit("class try")
    

#byte 1 byte
def rbyte(*num):
    if len(num) == 0:
        byte = lefile.read(1)
        #change = int.from_bytes(byte, endian, signed="False")
        change = struct.unpack('B',byte)[0]
        return change
    elif len(num) == 1 and type(num[0]) != str:
        tupple = []
        for i in range(num[0]):
            byte = lefile.read(1)
            #change = int.from_bytes(byte, endian, signed="False")
            change = struct.unpack('B',byte)[0]
            tupple.append(change)
        tupple = tuple(tupple)
        if num[0] == 1:
            tupple = tupple[0]
        return tupple
    elif len(num) == 2 and type(num[0]) != str:#endian define
        tupple = []
        num = list(num)
        if num[1] == '<':
            num[1] = "little"
        elif num[1] == '>':
            num[1] = "big"
        elif num[1] == "little" or num[1] == "big":
            pass
        else:
            print("wrong argument given")
            sys.exit("error found in reading data")
        for i in range(num[0]):
            byte = lefile.read(1)
            #change = int.from_bytes(byte, num[1], signed="False")
            change = struct.unpack('B',byte)[0]
            tupple.append(change)
        tupple = tuple(tupple)
        if num[0] == 1:
            tupple = tupple[0]
        return tupple
    elif len(num) == 1 and type(num[0]) == str:
        inputstr = num[0]
        if inputstr == "help":
            #explanation
            print("this function reads binary data as an unsigned Byte")
        else:
            print("wrong argument input, you might type help or an int")
    else:
        print("too many arguments given, only 1 argument permited")

def rByte(*num):
    if len(num) == 0:
        byte = lefile.read(1)
        #change = int.from_bytes(byte, endian, signed="True")
        change = struct.unpack('b',byte)[0]
        return change
    elif len(num) == 1 and type(num[0]) != str:
        tupple = []
        for i in range(num[0]):
            byte = lefile.read(1)
            #change = int.from_bytes(byte, endian, signed="True")
            change = struct.unpack('b',byte)[0]
            tupple.append(change)
        tupple = tuple(tupple)
        if num[0] == 1:
            tupple = tupple[0]
        return tupple
    elif len(num) == 2 and type(num[0]) != str:#endian define
        tupple = []
        num = list(num)
        if num[1] == '<':
            num[1] = "little"
        elif num[1] == '>':
            num[1] = "big"
        elif num[1] == "little" or num[1] == "big":
            pass
        else:
            print("wrong argument given")
            sys.exit("error found in reading data")
        for i in range(num[0]):
            byte = lefile.read(1)
            #change = int.from_bytes(byte, num[1], signed="True")
            change = struct.unpack('b',byte)[0  ]
            tupple.append(change)
        tupple = tuple(tupple)
        if num[0] == 1:
            tupple = tupple[0]
        return tupple
    elif len(num) == 1 and type(num[0]) == str:
        inputstr = num[0]
        if inputstr == "help":
            #explanation
            print("this function reads binary data as a signed Byte")
        else:
            print("wrong argument input, you might type help or an int")
    else:
        print("too many arguments given, only 1 argument permited")
    
#short 2 bytes
def rshort(*num):
    if len(num) == 0:
        byte = lefile.read(2)
        change = int.from_bytes(byte, endian, signed="False")
        return change
    elif len(num) == 1 and type(num[0]) != str:
        tupple = []
        for i in range(num[0]):
            byte = lefile.read(2)
            change = int.from_bytes(byte, endian, signed="False")
            tupple.append(change)
        tupple = tuple(tupple)
        if num[0] == 1:
            tupple = tupple[0]
        return tupple
    elif len(num) == 2 and type(num[0]) != str:
        tupple = []
        num = list(num)
        if num[1] == '<':
            num[1] = "little"
        elif num[1] == '>':
            num[1] = "big"
        elif num[1] == "little" or num[1] == "big":
            pass
        else:
            print("wrong argument given")
            sys.exit("error found in reading data")
        for i in range(num[0]):
            byte = lefile.read(2)
            change = int.from_bytes(byte, num[1], signed="False")
            tupple.append(change)
        tupple = tuple(tupple)
        if num[0] == 1:
            tupple = tupple[0]
        return tupple
    elif len(num) == 1 and type(num[0]) == str:
        inputstr = num[0]
        if inputstr == "help":
            #explanation
            print("this function reads binary data as an unsigned Short")
        else:
            print("wrong argument input, you might type help or an int")
    else:
        print("too many arguments given, only 1 argument permited")

def rShort(*num):
    if len(num) == 0:
        byte = lefile.read(2)
        change = int.from_bytes(byte, endian, signed="True")
        return change
    elif len(num) == 1 and type(num[0]) != str:
        tupple = []
        for i in range(num[0]):
            byte = lefile.read(2)
            change = int.from_bytes(byte, endian, signed="True")
            tupple.append(change)
        tupple = tuple(tupple)
        if num[0] == 1:
            tupple = tupple[0]
        return tupple
    elif len(num) == 2 and type(num[0]) != str:
        tupple = []
        num = list(num)
        if num[1] == '<':
            num[1] = "little"
        elif num[1] == '>':
            num[1] = "big"
        elif num[1] == "little" or num[1] == "big":
            pass
        else:
            print("wrong argument given")
            sys.exit("error found in reading data")
        for i in range(num[0]):
            byte = lefile.read(2)
            change = int.from_bytes(byte, num[1], signed="True")
            tupple.append(change)
        tupple = tuple(tupple)
        if num[0] == 1:
            tupple = tupple[0]
        return tupple
    elif len(num) == 1 and type(num[0]) == str:
        inputstr = num[0]
        if inputstr == "help":
            #explanation
            print("this function reads binary data as a signed Short")
        else:
            print("wrong argument input, you might type help or an int")
    else:
        print("too many arguments given, only 1 argument permited")
    
#int 4 bytes
def rint(*num):
    if len(num) == 0:
        byte = lefile.read(4)
        change = int.from_bytes(byte, endian, signed="False")
        return change
    elif len(num) == 1 and type(num[0]) != str:
        tupple = []
        for i in range(num[0]):
            byte = lefile.read(4)
            change = int.from_bytes(byte, endian, signed="False")
            tupple.append(change)
        tupple = tuple(tupple)
        if num[0] == 1:
            tupple = tupple[0]
        return tupple
    elif len(num) == 2 and type(num[0]) != str:
        tupple = []
        num = list(num)
        if num[1] == '<':
            num[1] = "little"
        elif num[1] == '>':
            num[1] = "big"
        elif num[1] == "little" or num[1] == "big":
            pass
        else:
            print("wrong argument given")
            sys.exit("error found in reading data")
        for i in range(num[0]):
            byte = lefile.read(4)
            change = int.from_bytes(byte, num[1], signed="False")
            tupple.append(change)
        tupple = tuple(tupple)
        if num[0] == 1:
            tupple = tupple[0]
        return tupple
    elif len(num) == 1 and type(num[0]) == str:
        inputstr = num[0]
        if inputstr == "help":
            #explanation
            print("this function reads binary data as an unsigned Integer")
        else:
            print("wrong argument input, you might type help or an int")
    else:
        print("too many arguments given, only 1 argument permited")
    
def rInt(*num):
    if len(num) == 0:
        byte = lefile.read(4)
        change = int.from_bytes(byte, endian, signed="True")
        return change
    elif len(num) == 1 and type(num[0]) != str:
        tupple = []
        for i in range(num[0]):
            byte = lefile.read(4)
            change = int.from_bytes(byte, endian, signed="True")
            tupple.append(change)
        tupple = tuple(tupple)
        if num[0] == 1:
            tupple = tupple[0]
        return tupple
    elif len(num) == 2 and type(num[0]) != str:
        tupple = []
        num = list(num)
        if num[1] == '<':
            num[1] = "little"
        elif num[1] == '>':
            num[1] = "big"
        elif num[1] == "little" or num[1] == "big":
            pass
        else:
            print("wrong argument given")
            sys.exit("error found in reading data")
        for i in range(num[0]):
            byte = lefile.read(4)
            change = int.from_bytes(byte, num[1], signed="True")
            tupple.append(change)
        tupple = tuple(tupple)
        if num[0] == 1:
            tupple = tupple[0]
        return tupple
    elif len(num) == 1 and type(num[0]) == str:
        inputstr = num[0]
        if inputstr == "help":
            #explanation
            print("this function reads binary data as a signed Integer")
        else:
            print("wrong argument input, you might type help or an int")
    else:
        print("too many arguments given, only 1 argument permited")
    

#float--------------------------------------------------------------------
#byte?
#signed short
def sshort(*num):
    if len(num) == 0:
        bytea = lefile.read(1)
        byteb = lefile.read(1)
        changea = int.from_bytes(bytea, endian, signed="True")
        changeb = (int.from_bytes(byteb, endian, signed="False"))/256
        changeb = round(changeb,roundvalue)
        output = changea + changeb
        return output
    elif len(num) == 1 and type(num[0]) != str:
        tupple = []
        for i in range(num[0]):
            bytea = lefile.read(1)
            byteb = lefile.read(1)
            changea = int.from_bytes(bytea, endian, signed="True")
            changeb = (int.from_bytes(byteb, endian, signed="False"))/256
            changeb = round(changeb,roundvalue)
            output = changea + changeb
            tupple.append(output)
        tupple = tuple(tupple)
        if num[0] == 1:
            tupple = tupple[0]
        return tupple
    elif len(num) == 2 and type(num[0]) != str:
        tupple = []
        num = list(num)
        if num[1] == '<':
            num[1] = "little"
        elif num[1] == '>':
            num[1] = "big"
        elif num[1] == "little" or num[1] == "big":
            pass
        else:
            print("wrong argument given")
            sys.exit("error found in reading data")
        for i in range(num[0]):
            bytea = lefile.read(1)
            byteb = lefile.read(1)
            changea = int.from_bytes(bytea, num[1], signed="True")
            changeb = (int.from_bytes(byteb, num[1], signed="False"))/256
            changeb = round(changeb,roundvalue)
            output = changea + changeb
            tupple.append(output)
        tupple = tuple(tupple)
        if num[0] == 1:
            tupple = tupple[0]
        return tupple
    elif len(num) == 1 and type(num[0]) == str:
        inputstr = num[0]
        if inputstr == "help":
            #explanation
            print("this function reads binary data as a Short_signed(byte1(int)+byte2/256(decimal;rounded to 4th))")
        else:
            print("wrong argument input, you might type help or an int")
    else:
        print("too many arguments given, only 1 argument permited")
    
#short
def fshort(*num):
    if len(num) == 0:
        byte = lefile.read(2)
        change = struct.unpack(endian2+'e',byte)[0]
        change = round(change,roundvalue)
        return change
    elif len(num) == 1 and type(num[0]) != str:
        tupple = []
        for i in range(num[0]):
            byte = lefile.read(2)
            change = struct.unpack(endian2+'e',byte)[0]
            change = round(change,roundvalue)
            tupple.append(change)
        tupple = tuple(tupple)
        if num[0] == 1:
            tupple = tupple[0]
        return tupple
    elif len(num) == 2 and type(num[0]) != str:
        tupple = []
        num = list(num)
        if num[1] == "little":
            num[1] = '<'
        elif num[1] == "big":
            num[1] = '>'
        elif num[1] == '>' or num[1] == '<':
            pass
        else:
            print("wrong argument given")
            sys.exit("error found in reading data")
        for i in range(num[0]):
            byte = lefile.read(2)
            change = struct.unpack(num[1]+'e',byte)[0]
            change = round(change,roundvalue)
            tupple.append(change)
        tupple = tuple(tupple)
        if num[0] == 1:
            tupple = tupple[0]
        return tupple
    elif len(num) == 1 and type(num[0]) == str:
        inputstr = num[0]
        if inputstr == "help":
            #explanation
            print("this function reads binary data as a Half-float")
        else:
            print("wrong argument input, you might type help or an int")
    else:
        print("too many arguments given, only 1 argument permited")
    
#int
def fint(*num):
    if len(num) == 0:
        byte = lefile.read(4)
        change = struct.unpack(endian2+'f',byte)[0]
        change = round(change,roundvalue)
        return change
    elif len(num) == 1 and type(num[0]) != str:
        tupple = []
        for i in range(num[0]):
            byte = lefile.read(4)
            change = struct.unpack(endian2+'f',byte)[0]
            change = round(change,roundvalue)
            tupple.append(change)
        tupple = tuple(tupple)
        if num[0] == 1:
            tupple = tupple[0]
        return tupple
    elif len(num) == 2 and type(num[0]) != str:
        tupple = []
        num = list(num)
        if num[1] == "little":
            num[1] = '<'
        elif num[1] == "big":
            num[1] = '>'
        elif num[1] == '>' or num[1] == '<':
            pass
        else:
            print("wrong argument given")
            sys.exit("error found in reading data")
        for i in range(num[0]):
            byte = lefile.read(4)
            change = struct.unpack(num[1]+'f',byte)[0]
            change = round(change,roundvalue)
            tupple.append(change)
        tupple = tuple(tupple)
        if num[0] == 1:
            tupple = tupple[0]
        return tupple
    elif len(num) == 1 and type(num[0]) == str:
        inputstr = num[0]
        if inputstr == "help":
            #explanation
            print("this function reads binary data as a Float")
        else:
            print("wrong argument input, you might type help or an int")
    else:
        print("too many arguments given, only 1 argument permited")
def tell(*args):
    if len(args) == 0:
        pos = lefile.tell()
        return pos
    elif len(args) == 1 and type(args[0]) == str:
        inputstr = args[0]
        if inputstr == "help":
            #explanation
            print("this function tells the current position in the binary stream")
        else:
            print("wrong argument input, you might type help or an int")
    else:
        print("too many arguments, use 1 argument or help")
def tellh(*args):
    if len(args) == 0:
        pos = hex(lefile.tell())
        return pos
    elif len(args) == 1 and type(args[0]) == str:
        inputstr = args[0]
        if inputstr == "help":
            #explanation
            print("this function tells the current position in the binary stream in hexadecimal")
        else:
            print("wrong argument input, you might type help or an int")
    else:
        print("too many arguments, use 1 argument or help")
#--------------------------------------------------------------------------------------------------------------  

```


also there is this one that was txrd2 specific:

```
from glob import glob
import struct
from struct import *
import sys
#f = mrp.get_bfile()

#copy from nines.py
#----------------------------------------------------------------------------------------------

#variables
endian = "little"
endian2 = '<'
roundvalue = 5

#byte 1 byte
def rbyte(*num):
    if len(num) == 0:
        byte = lefile.read(1)
        #change = int.from_bytes(byte, endian, signed="False")
        change = struct.unpack('B',byte)[0]
        return change
    elif len(num) == 1 and type(num[0]) != str:
        tupple = []
        for i in range(num[0]):
            byte = lefile.read(1)
            #change = int.from_bytes(byte, endian, signed="False")
            change = struct.unpack('B',byte)[0]
            tupple.append(change)
        tupple = tuple(tupple)
        if num[0] == 1:
            tupple = tupple[0]
        return tupple
    elif len(num) == 2 and type(num[0]) != str:#endian define
        tupple = []
        num = list(num)
        if num[1] == '<':
            num[1] = "little"
        elif num[1] == '>':
            num[1] = "big"
        elif num[1] == "little" or num[1] == "big":
            pass
        else:
            print("wrong argument given")
            sys.exit("error found in reading data")
        for i in range(num[0]):
            byte = lefile.read(1)
            #change = int.from_bytes(byte, num[1], signed="False")
            change = struct.unpack('B',byte)[0]
            tupple.append(change)
        tupple = tuple(tupple)
        if num[0] == 1:
            tupple = tupple[0]
        return tupple
    elif len(num) == 1 and type(num[0]) == str:
        inputstr = num[0]
        if inputstr == "help":
            #explanation
            print("this function reads binary data as an unsigned Byte")
        else:
            print("wrong argument input, you might type help or an int")
    else:
        print("too many arguments given, only 1 argument permited")

def rByte(*num):
    if len(num) == 0:
        byte = lefile.read(1)
        #change = int.from_bytes(byte, endian, signed="True")
        change = struct.unpack('b',byte)[0]
        return change
    elif len(num) == 1 and type(num[0]) != str:
        tupple = []
        for i in range(num[0]):
            byte = lefile.read(1)
            #change = int.from_bytes(byte, endian, signed="True")
            change = struct.unpack('b',byte)[0]
            tupple.append(change)
        tupple = tuple(tupple)
        if num[0] == 1:
            tupple = tupple[0]
        return tupple
    elif len(num) == 2 and type(num[0]) != str:#endian define
        tupple = []
        num = list(num)
        if num[1] == '<':
            num[1] = "little"
        elif num[1] == '>':
            num[1] = "big"
        elif num[1] == "little" or num[1] == "big":
            pass
        else:
            print("wrong argument given")
            sys.exit("error found in reading data")
        for i in range(num[0]):
            byte = lefile.read(1)
            #change = int.from_bytes(byte, num[1], signed="True")
            change = struct.unpack('b',byte)[0  ]
            tupple.append(change)
        tupple = tuple(tupple)
        if num[0] == 1:
            tupple = tupple[0]
        return tupple
    elif len(num) == 1 and type(num[0]) == str:
        inputstr = num[0]
        if inputstr == "help":
            #explanation
            print("this function reads binary data as a signed Byte")
        else:
            print("wrong argument input, you might type help or an int")
    else:
        print("too many arguments given, only 1 argument permited")
    
#short 2 bytes
def rshort(*num):
    if len(num) == 0:
        byte = lefile.read(2)
        change = int.from_bytes(byte, endian, signed="False")
        return change
    elif len(num) == 1 and type(num[0]) != str:
        tupple = []
        for i in range(num[0]):
            byte = lefile.read(2)
            change = int.from_bytes(byte, endian, signed="False")
            tupple.append(change)
        tupple = tuple(tupple)
        if num[0] == 1:
            tupple = tupple[0]
        return tupple
    elif len(num) == 2 and type(num[0]) != str:
        tupple = []
        num = list(num)
        if num[1] == '<':
            num[1] = "little"
        elif num[1] == '>':
            num[1] = "big"
        elif num[1] == "little" or num[1] == "big":
            pass
        else:
            print("wrong argument given")
            sys.exit("error found in reading data")
        for i in range(num[0]):
            byte = lefile.read(2)
            change = int.from_bytes(byte, num[1], signed="False")
            tupple.append(change)
        tupple = tuple(tupple)
        if num[0] == 1:
            tupple = tupple[0]
        return tupple
    elif len(num) == 1 and type(num[0]) == str:
        inputstr = num[0]
        if inputstr == "help":
            #explanation
            print("this function reads binary data as an unsigned Short")
        else:
            print("wrong argument input, you might type help or an int")
    else:
        print("too many arguments given, only 1 argument permited")

def rShort(*num):
    if len(num) == 0:
        byte = lefile.read(2)
        change = int.from_bytes(byte, endian, signed="True")
        return change
    elif len(num) == 1 and type(num[0]) != str:
        tupple = []
        for i in range(num[0]):
            byte = lefile.read(2)
            change = int.from_bytes(byte, endian, signed="True")
            tupple.append(change)
        tupple = tuple(tupple)
        if num[0] == 1:
            tupple = tupple[0]
        return tupple
    elif len(num) == 2 and type(num[0]) != str:
        tupple = []
        num = list(num)
        if num[1] == '<':
            num[1] = "little"
        elif num[1] == '>':
            num[1] = "big"
        elif num[1] == "little" or num[1] == "big":
            pass
        else:
            print("wrong argument given")
            sys.exit("error found in reading data")
        for i in range(num[0]):
            byte = lefile.read(2)
            change = int.from_bytes(byte, num[1], signed="True")
            tupple.append(change)
        tupple = tuple(tupple)
        if num[0] == 1:
            tupple = tupple[0]
        return tupple
    elif len(num) == 1 and type(num[0]) == str:
        inputstr = num[0]
        if inputstr == "help":
            #explanation
            print("this function reads binary data as a signed Short")
        else:
            print("wrong argument input, you might type help or an int")
    else:
        print("too many arguments given, only 1 argument permited")
    
#int 4 bytes
def rint(*num):
    if len(num) == 0:
        byte = lefile.read(4)
        change = int.from_bytes(byte, endian, signed="False")
        return change
    elif len(num) == 1 and type(num[0]) != str:
        tupple = []
        for i in range(num[0]):
            byte = lefile.read(4)
            change = int.from_bytes(byte, endian, signed="False")
            tupple.append(change)
        tupple = tuple(tupple)
        if num[0] == 1:
            tupple = tupple[0]
        return tupple
    elif len(num) == 2 and type(num[0]) != str:
        tupple = []
        num = list(num)
        if num[1] == '<':
            num[1] = "little"
        elif num[1] == '>':
            num[1] = "big"
        elif num[1] == "little" or num[1] == "big":
            pass
        else:
            print("wrong argument given")
            sys.exit("error found in reading data")
        for i in range(num[0]):
            byte = lefile.read(4)
            change = int.from_bytes(byte, num[1], signed="False")
            tupple.append(change)
        tupple = tuple(tupple)
        if num[0] == 1:
            tupple = tupple[0]
        return tupple
    elif len(num) == 1 and type(num[0]) == str:
        inputstr = num[0]
        if inputstr == "help":
            #explanation
            print("this function reads binary data as an unsigned Integer")
        else:
            print("wrong argument input, you might type help or an int")
    else:
        print("too many arguments given, only 1 argument permited")
    
def rInt(*num):
    if len(num) == 0:
        byte = lefile.read(4)
        change = int.from_bytes(byte, endian, signed="True")
        return change
    elif len(num) == 1 and type(num[0]) != str:
        tupple = []
        for i in range(num[0]):
            byte = lefile.read(4)
            change = int.from_bytes(byte, endian, signed="True")
            tupple.append(change)
        tupple = tuple(tupple)
        if num[0] == 1:
            tupple = tupple[0]
        return tupple
    elif len(num) == 2 and type(num[0]) != str:
        tupple = []
        num = list(num)
        if num[1] == '<':
            num[1] = "little"
        elif num[1] == '>':
            num[1] = "big"
        elif num[1] == "little" or num[1] == "big":
            pass
        else:
            print("wrong argument given")
            sys.exit("error found in reading data")
        for i in range(num[0]):
            byte = lefile.read(4)
            change = int.from_bytes(byte, num[1], signed="True")
            tupple.append(change)
        tupple = tuple(tupple)
        if num[0] == 1:
            tupple = tupple[0]
        return tupple
    elif len(num) == 1 and type(num[0]) == str:
        inputstr = num[0]
        if inputstr == "help":
            #explanation
            print("this function reads binary data as a signed Integer")
        else:
            print("wrong argument input, you might type help or an int")
    else:
        print("too many arguments given, only 1 argument permited")
    

#float--------------------------------------------------------------------
#byte?
#signed short
def sshort(*num):
    if len(num) == 0:
        bytea = lefile.read(1)
        byteb = lefile.read(1)
        changea = int.from_bytes(bytea, endian, signed="True")
        changeb = (int.from_bytes(byteb, endian, signed="False"))/256
        changeb = round(changeb,roundvalue)
        output = changea + changeb
        return output
    elif len(num) == 1 and type(num[0]) != str:
        tupple = []
        for i in range(num[0]):
            bytea = lefile.read(1)
            byteb = lefile.read(1)
            changea = int.from_bytes(bytea, endian, signed="True")
            changeb = (int.from_bytes(byteb, endian, signed="False"))/256
            changeb = round(changeb,roundvalue)
            output = changea + changeb
            tupple.append(output)
        tupple = tuple(tupple)
        if num[0] == 1:
            tupple = tupple[0]
        return tupple
    elif len(num) == 2 and type(num[0]) != str:
        tupple = []
        num = list(num)
        if num[1] == '<':
            num[1] = "little"
        elif num[1] == '>':
            num[1] = "big"
        elif num[1] == "little" or num[1] == "big":
            pass
        else:
            print("wrong argument given")
            sys.exit("error found in reading data")
        for i in range(num[0]):
            bytea = lefile.read(1)
            byteb = lefile.read(1)
            changea = int.from_bytes(bytea, num[1], signed="True")
            changeb = (int.from_bytes(byteb, num[1], signed="False"))/256
            changeb = round(changeb,roundvalue)
            output = changea + changeb
            tupple.append(output)
        tupple = tuple(tupple)
        if num[0] == 1:
            tupple = tupple[0]
        return tupple
    elif len(num) == 1 and type(num[0]) == str:
        inputstr = num[0]
        if inputstr == "help":
            #explanation
            print("this function reads binary data as a Short_signed(byte1(int)+byte2/256(decimal;rounded to 4th))")
        else:
            print("wrong argument input, you might type help or an int")
    else:
        print("too many arguments given, only 1 argument permited")
    
#short
def fshort(*num):
    if len(num) == 0:
        byte = lefile.read(2)
        change = unpack(endian2+'e',byte)[0]
        change = round(change,roundvalue)
        return change
    elif len(num) == 1 and type(num[0]) != str:
        tupple = []
        for i in range(num[0]):
            byte = lefile.read(2)
            change = unpack(endian2+'e',byte)[0]
            change = round(change,roundvalue)
            tupple.append(change)
        tupple = tuple(tupple)
        if num[0] == 1:
            tupple = tupple[0]
        return tupple
    elif len(num) == 2 and type(num[0]) != str:
        tupple = []
        num = list(num)
        if num[1] == "little":
            num[1] = '<'
        elif num[1] == "big":
            num[1] = '>'
        elif num[1] == '>' or num[1] == '<':
            pass
        else:
            print("wrong argument given")
            sys.exit("error found in reading data")
        for i in range(num[0]):
            byte = lefile.read(2)
            change = unpack(num[1]+'e',byte)[0]
            change = round(change,roundvalue)
            tupple.append(change)
        tupple = tuple(tupple)
        if num[0] == 1:
            tupple = tupple[0]
        return tupple
    elif len(num) == 1 and type(num[0]) == str:
        inputstr = num[0]
        if inputstr == "help":
            #explanation
            print("this function reads binary data as a Half-float")
        else:
            print("wrong argument input, you might type help or an int")
    else:
        print("too many arguments given, only 1 argument permited")
    
#int
def fint(*num):
    if len(num) == 0:
        byte = lefile.read(4)
        change = unpack(endian2+'f',byte)[0]
        change = round(change,roundvalue)
        return change
    elif len(num) == 1 and type(num[0]) != str:
        tupple = []
        for i in range(num[0]):
            byte = lefile.read(4)
            change = unpack(endian2+'f',byte)[0]
            change = round(change,roundvalue)
            tupple.append(change)
        tupple = tuple(tupple)
        if num[0] == 1:
            tupple = tupple[0]
        return tupple
    elif len(num) == 2 and type(num[0]) != str:
        tupple = []
        num = list(num)
        if num[1] == "little":
            num[1] = '<'
        elif num[1] == "big":
            num[1] = '>'
        elif num[1] == '>' or num[1] == '<':
            pass
        else:
            print("wrong argument given")
            sys.exit("error found in reading data")
        for i in range(num[0]):
            byte = lefile.read(4)
            change = unpack(num[1]+'f',byte)[0]
            change = round(change,roundvalue)
            tupple.append(change)
        tupple = tuple(tupple)
        if num[0] == 1:
            tupple = tupple[0]
        return tupple
    elif len(num) == 1 and type(num[0]) == str:
        inputstr = num[0]
        if inputstr == "help":
            #explanation
            print("this function reads binary data as a Float")
        else:
            print("wrong argument input, you might type help or an int")
    else:
        print("too many arguments given, only 1 argument permited")
def tell(*args):
    if len(args) == 0:
        pos = lefile.tell()
        return pos
    elif len(args) == 1 and type(args[0]) == str:
        inputstr = args[0]
        if inputstr == "help":
            #explanation
            print("this function tells the current position in the binary stream")
        else:
            print("wrong argument input, you might type help or an int")
    else:
        print("too many arguments, use 1 argument or help")
def tellh(*args):
    if len(args) == 0:
        pos = hex(lefile.tell())
        return pos
    elif len(args) == 1 and type(args[0]) == str:
        inputstr = args[0]
        if inputstr == "help":
            #explanation
            print("this function tells the current position in the binary stream in hexadecimal")
        else:
            print("wrong argument input, you might type help or an int")
    else:
        print("too many arguments, use 1 argument or help")
#-----------------------------------------------------------------------------------------   

debug = 1
debug_mesh = 26




#txr3 folder scan script


curfolder = "E:\\Downloads\\ModelResearcherPro\\Nueva carpeta\\txr3\\c1\\2022\\txrd2\\sections\\akagi_1\\local0\\"
#localfolder = "E:\\Downloads\\ModelResearcherPro\\Nueva carpeta\\txr3\\testoval\\txr3_oval_texture_png\\texture\\local\\"
#globalfolder = "E:\\Downloads\\ModelResearcherPro\\Nueva carpeta\\txr3\\testoval\\txr3_oval_texture_png\\texture\\global\\"
files = (glob(curfolder+"*"))

#print(files)
#sys.exit()


#verts = []
#uvs = []
#faces = []
#curfi = -1
#mat = open('mat.txt', 'w')
#facesfile = open('faces.txt', 'w')
#variables = []
meshes = []
for i in range(1):#len(files)):
    i = 2
    f = lefile = open(files[i],"rb")
    curfile = files[i].split("\\")[-1]
    f.seek(0,2)
    eof = f.tell()
    f.seek(0)
    materials = []
    new = 0
    filecount = 0
    print ("***************",i,curfile)
    meshnum = rInt()
    #meshnum = 1
    f.seek(12,1)
    for i in range(meshnum):
        a = rInt()
        b = rInt()
        mesh = curfile+"_mesh_"+ str(i)+"_mat_"+str(a)+"_"+str(b)
        materials.append(mesh)
        f.seek(8,1)
        #print(mesh)
    #print(f.tellHex())
    #jump = (meshnum*16)
    #f.seek(jump)

    #override
    #materials = ["test"]
    #meshnum = 1

    #f.seek(-16,1)
    #sys.exit()
    #print ("start "+f.tellHex())
    for i in range(meshnum):
        run = i
        #print("mesh "+ str(i)+"\n",file = mat)
        curmesh = materials[i]
        #print(curmesh, tellh())
        verts = []
        uvs = []
        faces = []
        facestri = []
        normals = []
        curfi = -1
        some_info = [rInt() for i in range(4)]
        #material = some_info[2]???
        #print("mat???", some_info[2], some_info[0])
        repeat = some_info[1]
        some_pos = [fint() for i in range(8)]
        #f.seek(20,1)
        #repeat = f.readInt()
        #f.seek(40,1)
        for i in range(repeat):
            if run == debug_mesh and debug == 1:
                print("\nRepeat "+ str(i)+"\thex ="+str(tellh())+"\n")#,file = mat)
            #currep="_rep_"+str(i)
            #curmesha =curmesh+currep
            #verts = []
            #uvs = []
            #faces = []
            #facestri = []
            #curfi = -1
            start = tell()
            leng = rShort()
            meshleng = ((leng*16)+16)
            if leng != 0:
                f.seek(10,1)
                count = rInt()
                f.seek(48,1)
                for i in range(count):
                    verts.append(fint(3))
                #f.seek(4,1)
                uvs_flag = [rByte() for i in range(4)]
                if uvs_flag[3] == 0x65:
                    for i in range(count):
                        uv = rShort(2)
                        uvs.append(uv)
                else:
                    f.seek(-4,1)
                    for i in range(count):
                        uv = (0,0)
                        uvs.append(uv)
                #f.seek(4,1)
                face_flag = [rByte() for i in range(4)]
                if face_flag[3] == 0x6e:
                    ffcheck = 0
                    #print (curmesh+"\t"+currep+"\t"+str(f.tellHex()))
                    for i in range(count):
                        curfi = curfi + 1
                        #f.seek(3,1)
                        reada = rByte()
                        readb = rByte()
                        readc = rByte()
                        color_data = [reada,readb,readc]
                        maths = [(int(i/0x80)*(-1))+((i%0x80)/0x80)for i in color_data]
                        normals.append(maths)
                        readd = rByte()
                        binar = str(bin(readd))
                        binary = int(binar[-1])
                        facea = curfi - 2
                        faceb = curfi - 1
                        facec = curfi
                        if binary == 1 or i < 2:
                            if ffcheck == 0:
                                #print("\n\t\t\t\t\tFFFF",file = mat)
                                faces.append(65535)
                                ffcheck = 1
                            #else:
                                #ffcheck = 0
                        else:
                            if (i % 2) == 0:
                                facestri.append((facea,faceb,facec))
                            else:
                                facestri.append((facea,facec,faceb))
                            ffcheck = 0
                        faces.append(curfi)
                        #new = read
                        #if (len(variables) == 0:
                        #    variables.append(new)
                    
                        #print ("current face "+str(i)+"\treada = "+hex(reada)+"\treadb = "+hex(readb)+"\treadc = "+hex(readc)+"\treadd = "+hex(readd)+"\t\tbin = "+str(binary), file = mat)    
                    faces.append(65535)
                    f.seek(start)
                    f.seek(meshleng,1)
                else:
                    for i in range(count-2):
                        facea = i
                        faceb = i + 1
                        facec = i + 2
                        if (i % 2) == 0:
                            facestri.append((facea,faceb,facec))
                        else:
                            facestri.append((facea,facec,faceb))
                    f.seek(start)
                    f.seek(meshleng,1)
            #if (curfi + 1) > count:
                #print ("----------------------------------------------------------------------------------------------------------------------",file =facesfile)
            #print(curmesh+"\t"+currep+"\t"+str(f.tellHex())+"\nvc = "+str(count)+"\tmaxface = "+str(curfi + 1),file = facesfile)
            #print(facestri)#,file = facesfile)
        
        
            #faces.append(65535)
        if run == debug_mesh and debug == 1:
            mrp.create_mesh(curmesh)
            mesh = mrp.get_mesh(curmesh)
            mesh.set_vertices(verts)
            #mesh.set_faces(faces,fm="TStripFF")
            mesh.set_faces(facestri)
            mesh.set_uvs(uvs,tp="Short")
            #mesh.set_uvs_indices(faces,fm="TStripFF")
            mesh.set_uvs_indices(facestri)
            #mesh.set_normals(normals)
            meshes.append(curmesh)
        elif debug == 0:
            mrp.create_mesh(curmesh)
            mesh = mrp.get_mesh(curmesh)
            mesh.set_vertices(verts)
            #mesh.set_faces(faces,fm="TStripFF")
            mesh.set_faces(facestri)
            mesh.set_uvs(uvs,tp="Short")
            #mesh.set_uvs_indices(faces,fm="TStripFF")
            mesh.set_uvs_indices(facestri)
            #mesh.set_normals(normals)
            meshes.append(curmesh)
        f.seek(16,1)
        #mrp.print_mesh()
        #print("\n---------------------------------------------------------------------------\n",file = mat)
    f.seek(16,1)
    f.close()
mrp.render(meshes)
print ("end ")#+tellh())
print ("------------------")

```


the nines.py script is really not that hard to guess, it be also exemplified on the first script here, just how to read binary data...

also regarding the materials and lists, the problem here with the "hashes" is that in some sense they don't make much sense in the long run, in TXR3 the parts and locals kept the same structure regarding the Global position, you had one int that was the type of texture used(global, local, or animation folder) and then the number that is within that stack; but here with TXRD2 the problem is that from one local to the next one those values might change, sometimes it is coherent, sometimes not, so that is why i never linked properly what texture goes where or how.

and lastly, yeah, so long only using any ucl unpack that gets it is little endian you can unpack them, i think i modified back then the ITC script to make it work and that was all, also some others do use zlib iirc (TXR Zero i think); but its basically a copy of the method used with UCL.

Regarding my scripts, they are made for MRP, also i had been working on this library of mine to make it easier for me to recreate them outside MRP, and also besides that, i think one important part that might interest you is that in the second script, the TXRD2 specific one i did debug the UV gathering method until it worked, just in case you had been struggling or something, it be a bit complex iirc.

full track list

```
akagi_0
c33
c34

akagi_1
c35 collider
c36 skybox
c37 global
c38-c5b checkpoints
c5c local 0
c96 local 1
d04 local 2
d39 local 3
d50 end

akagi_2
d51 collider
d52 skybox
d53 global
d54-d77 checkpoints
d78 local 0
db2 local 1
e20 local 2
e55 local 4
e6e end

akagi_3
e6d collider
e6e skybox
e6f global
e70-e93 checkpoints
e94 local 0
ece local 1
f3c local 2
f71 local 3
f88 end

akagi_4
f89 collider
f8a skybox
f8b global
f8c-faf checkpoint
fb0 local 0
fea local 1
1058 local 2
108d local 3
10a4 end

----------------------------------------
aso_0
10a5
10a6

aso_1
10a7 collider
10a8 skybox
10a9 global
10aa-10cd checkpoint
10ce local 0		38
10f5 local 1		87
114d local 2		104
11b6 local 3		115
1229 end

aso_2
122a collider
122b skybox
122c global
122d-1250 checkpoint
1251 local 0
1278 local 1
12d0 local 2
1339 local 3
13ac end

aso_3
13ad collider
13ae skybox
13af global
13b0-13d3 checkpoint
13d4 local 0
13fb local 1
1453 local 2
14bc local 3
152f end

aso_4
1530 collider
1531 skybox
1532 global
1533-1556 checkpoint
1557 local 0
157e local 1
15d6 local 2
163f local 3
16b2 end

----------------------------------------
gymkhana_0
16b3 start
16b4 end

gymkhana_1
16b5 collider?
16b6 skybox?
16b7 local 0?
16b8 what 0?
16e7 local 1?
16e8 what 1?
16fc end

gymkhana_2
16e5 collider?
16e6 skybox?
16e7 local 0?
16e8 what 0?
16fc end

----------------------------------------
hakone_0
16fd start
16fe end

hakone_1
16ff collider
1700 skybox
1701 global
1702-1725 checkpoints
1726 local 0
1759 local 1
17b8 local 2
17f9

hakone_2
17fa
18f4

hakone_3
18f5
19ef

hakone_4
19f0
1aea

----------------------------------------
happogahara_0
1aeb start
1aec end

happogahara_1
1aed collider
1aee skybox
1aef global
1af0-1af3 checkpoint
1af4 what 0? local 0
1b38 what 1? local 1
1b6a end

----------------------------------------
haruna_0
1b6b
1b6c

haruna_1
1b6d collider
1b6e skybox
1b6f global
1b70-1b93 checkpoint
1b94 local 0
1bd3 local 1
1c65 local 2
1ce0 end

haruna_2
1ce1
1e54

haruna_3
1e55
1fc8

haruna_4
1fc9
213c

----------------------------------------
hiroshima_0
213d
213e

hiroshima_1
213f collider
2140 skybox
2141 global
2142-2165 checkpoint
2166 local 0
2210 what? local 1
2242 end

hiroshima_2
2243
2346

hiroshima_3
2347
244a

hiroshima_4
244b
254e

----------------------------------------
hokkaido_0
254f
2550

hokkaido_1
2551 collider
2552 skybox
2553 global
2554-2577 checkpoint
2578 local 0
25b5 local 1
25d1 local 2
2602 local 3
2658 end


hokkaido_2
hokkaido_3
hokkaido_4

----------------------------------------
nikko_0
2971
2972

nikko_1
2973 collider
2974 skybox
2975 global
2976-2999 checkpoint
299a local 0
2a21 local 1
2aec local 2
2b41 end

nikko_2
nikko_3
nikko_4

----------------------------------------
kirigamine_0
30af
30b0

kirigamine_1
30b1 collider
30b2 skybox
30b3 global
03b4-30b7 checkpoint
30b8 local 0
3114 local 1

----------------------------------------
shiga_0
3147
3148

shiga_1
3149 collider
314a skybox
314b global
314c-36f checkpoint
3170 local 0
31d3 local 1
3249 end


shiga_2
shiga_3
shiga_4

----------------------------------------
myougi_0
35bc
35bd

myougi_1
35be collider
35bf skybox
35c0 global
35c1-35c4 checkpoint
35c5 local 0
35ec local 1
361e end

----------------------------------------
yuki_0
361f
3620

yuki_1
3621 collider
3622 skybox
3623 global
3624-3627 checkpoint
3628 local 0
3665 local 1
3697 end

----------------------------------------
ohtarumi_0
3698
3699

ohtarumi_0
369a collider
369b skybox
369c global
369d-36a0 checkpoint
36a1 local 0
36f1 local 1
3723 end

----------------------------------------
test_0
3724
3725

test_1
3726 collider
3727 skybox
3728 global
3729 local 0
3752 end

test_2
test_3

----------------------------------------
omote_0
37ad
37ae

omote_1
37af collider
37b0 skybox
37b1 global
37b2-37d5 checkpoint
37d6 local 0
3816 local 1
3858 local 2
3884 local 3
38b6 end

----------------------------------------
nanamagari_0
3bcf
3bd0

nanamagari_1
3bd1 collider
3bd2 skybox
3bd3 global
3bd4-3bd7 checkpoint
3bd8 local 0
3bef local 1
3c21 end

----------------------------------------
ura_0
3c22
3c23

ura_1
3c24 collider
3c25 skybox
3c26 global
3c27-3c4a checkpoint
3c4b local 0
3cef end

ura_2
ura_3
ura_4

----------------------------------------
usui_0
3f54
3f55

usui_1
3f56 collider
3f57 skybox
3f58 global
3f59-3f5c checkpoint
3f5d local 0
3fa0 end

----------------------------------------
yokohama_0
3fa1
3fa2

yokohama_1
3fa3 collider
3fa4 skybox
3fa5 global
3fa6-3fa9 checkpoint
3faa local 0
3fe1 end

----------------------------------------
zao_0
3fe2
3fe3

zao_1
3f34 collider
3fe5 skybox
3fe6 global
3fe7-400a checkpoint
400b local 0
4069 local 1
40fe local 2
4186 local 3
4224 end

zao_2
zao_3
zao_4

```


cars list

```
98 honda civic eg
9a honda civic eg
a6 honda civic newish
af honda civic ef
dd acura integra
14a mazda 323
16a mazda miata nb
1a3 mazda rx7 fd
1c1 mitsu colt alto
1e5 mitsu mirage
1f9 mitsu gallant vr6
23b mitsu evo 5
2a0 nissan march
2c9 nissan almera
33b nissan s14
36f nissan p10
37a nissan primera p12
384 nissan laurel c33
390 nissan laurel c34
39c nissan laurel c35
413 nissan er34
476 nissan 350z
4e4 subbie impreza bugeye
4e5 subbie impreza bugeye
4ef subbie impreza gb
4f4 subbie impreza gb
4ff subbie impreza 22 wagon
508 subbie impreza bugeye wagon
552 subbie legacy 97
555 subbie legacy 97
55e subbie legacy wagon 02
568 subbie legacy 02
575 subbie legacy 02
581 subbie legacy 02
589 subbie legacy b4
58a subbie legacy b4
594 subbie legacy touring wagon
596 subbie legacy touring wagon
597 subbie legacy touring wagon
599 subbie legacy touring wagon
5a0 subbie alcyone old svx
5aa subbie alcyone new

```


cheers bruv
## Post #21
- Username: GreenTrafficLight
- Rank: beginner
- Number of posts: 28
- Joined date: Mon Apr 26, 2021 6:54 am
- Post datetime: 2022-07-17T22:32:50+00:00
- Post Title: Re: Funky as hell FIs

> Reply from Machinedramon ↑Fri Jul 15, 2022 3:39 am at Fri Jul 15, 2022 3:39 am
>
> 
the TXRD2 specific one i did debug the UV gathering method until it worked, just in case you had been struggling or something, it be a bit complex iirc.

Wait I don't get it, you managed to get the UV properly scaled ? Because what I do is reading the UV values as short then dividing them by 32767, but after that you need to multiply the values by 8 or 16 to get the correct scale.

Edit : Even by dividing the shorts by 4096, some UV need to be scaled, it seems that it either divided by 2048 or 4096, and sometimes you can the X value divied by 4096 and the Y value by 2048, I think the gamecode might do a special operation.
## Post #22
- Username: Machinedramon
- Rank: advanced
- Number of posts: 77
- Joined date: Tue Apr 09, 2019 1:13 am
- Post datetime: 2022-07-19T13:12:51+00:00
- Post Title: Re: Funky as hell FIs

> Reply from GreenTrafficLight ↑Mon Jul 18, 2022 6:32 am at Mon Jul 18, 2022 6:32 am
>
> 
Machinedramon wrote: ↑Fri Jul 15, 2022 3:39 am
the TXRD2 specific one i did debug the UV gathering method until it worked, just in case you had been struggling or something, it be a bit complex iirc.


Wait I don't get it, you managed to get the UV properly scaled ? Because what I do is reading the UV values as short then dividing them by 32767, but after that you need to multiply the values by 8 or 16 to get the correct scale.

Edit : Even by dividing the shorts by 4096, some UV need to be scaled, it seems that it either divided by 2048 or 4096, and sometimes you can the X value divied by 4096 and the Y value by 2048, I think the gamecode might do a special operation.

i think i had solved the issue but no, i have been checking, thats why in my code i was debugging it as a set of bits to see if the upper ones were some scalar thingy, but actually, its more like the values as is can be interpreted correctly in current form but some will need to be multiplied by 2; so my theory is that one of the bits per each is gotta be some flag and not really part of the format; which one, i dont know yet....
## Post #23
- Username: GreenTrafficLight
- Rank: beginner
- Number of posts: 28
- Joined date: Mon Apr 26, 2021 6:54 am
- Post datetime: 2022-07-29T00:53:01+00:00
- Post Title: Re: Funky as hell FIs

> Reply from Machinedramon ↑Tue Jul 19, 2022 9:12 pm at Tue Jul 19, 2022 9:12 pm
>
> 
so my theory is that one of the bits per each is gotta be some flag and not really part of the format; which one, i dont know yet....

After doing some things with Cheat Engine, I found that the UV scaling are tied to the textures itself and not the UV data in the mesh. Basically the [TIM2 file](https://openkh.dev/common/tm2.html) after the height have datas like GS which probably tell the game how to render the texture ( make me wonder if it's a special case with TXR2 or not ). I found that by replacing the material and each texture got it's own scaling, not the mesh.

BTW I don't think map have normals, when I modified the three values ( before the flag reset ), it change the color of the mesh which pretty much show that it's probably vertex colors ( or something to do with material color since the middle road lane color of Hakone isn't in the TIM2 file ).
## Post #24
- Username: Machinedramon
- Rank: advanced
- Number of posts: 77
- Joined date: Tue Apr 09, 2019 1:13 am
- Post datetime: 2022-08-01T11:50:26+00:00
- Post Title: Re: Funky as hell FIs

> Reply from GreenTrafficLight ↑Fri Jul 29, 2022 8:53 am at Fri Jul 29, 2022 8:53 am
>
> 
Machinedramon wrote: ↑Tue Jul 19, 2022 9:12 pm
so my theory is that one of the bits per each is gotta be some flag and not really part of the format; which one, i dont know yet....


After doing some things with Cheat Engine, I found that the UV scaling are tied to the textures itself and not the UV data in the mesh. Basically the TIM2 file after the height have datas like GS which probably tell the game how to render the texture ( make me wonder if it's a special case with TXR2 or not ). I found that by replacing the material and each texture got it's own scaling, not the mesh.

BTW I don't think map have normals, when I modified the three values ( before the flag reset ), it change the color of the mesh which pretty much show that it's probably vertex colors ( or something to do with material color since the middle road lane color of Hakone isn't in the TIM2 file ).

well im not 100 percent sure if that is normal or not, i will try on my side to unpack tim2 textures and analize the containers if i can see any coorelation with the palettes/sizes, all i know since txr3 unpacking is that there had always been some problem with uvs and faces for some games, but thanks for the hint, if i find anything ill post it here back
